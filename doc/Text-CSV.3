.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "STDIN 1"
.TH STDIN 1 "2022-04-19" "perl v5.34.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
Note that updating these docs is an ongoing process and some perl5 idioms
might not have been translated yet into correct raku idiom. My bad. Sorry.
(Feedback welcome)
.SH "NAME"
Text::CSV \- comma\-separated values manipulation routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Text::CSV;
\&
\& # Read whole file in memory
\& my @aoa = csv(in => "data.csv");  # as array of arrays
\& my @aoh = csv(in => "data.csv",
\&               headers => "auto"); # as array of hashes
\&
\& # Write array of arrays as csv file
\& csv(in => @aoa, out => "file.csv", sep => ";");
\&
\& my @rows;
\& # Read/parse CSV
\& my $csv = Text::CSV.new;
\& my $fh  = open "test.csv", :r, :!chomp;
\& while (my @row = $csv.getline($fh)) {
\&     @row[2] ~~ m/pattern/ or next; # 3rd field should match
\&     @rows.push: @row;
\&     }
\& $fh.close;
\&
\& # and write as CSV
\& $fh = open "new.csv", :w;
\& $csv.say($fh, $_) for @rows;
\& $fh.close;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::CSV provides facilities for the composition and decomposition of
comma-separated values. An instance of the Text::CSV class will combine
fields into a \f(CW\*(C`CSV\*(C'\fR string and parse a \f(CW\*(C`CSV\*(C'\fR string into fields.
.PP
The module accepts either strings or files as input and support the use of
user-specified characters (or sequences thereof) for delimiters, separators,
and escapes.
.PP
In all following documentation, \f(CW\*(C`WIP\*(C'\fR stands for \*(L"Work In Progress\*(R" and
\&\f(CW\*(C`NYI\*(C'\fR for \*(L"Not Yet Implemented\*(R". The goal is to get rid of all of those.
.SS "Embedded newlines"
.IX Subsection "Embedded newlines"
\&\fBImportant Note\fR: The default behavior is to accept only \s-1UTF\-8\s0 characters.
.PP
But you still have the problem that you have to pass a correct line to the
\&\*(L"parse\*(R" method, which is more complicated from the usual point of usage:
.PP
.Vb 5
\& my $csv = Text::CSV.new;
\& for lines() : eager {          #  WRONG!
\&     $csv.parse($_);
\&     my @fields = $csv.fields;
\&     }
.Ve
.PP
this will break for several reasons. The default open mode is to \f(CW\*(C`chomp\*(C'\fR
lines, which will also remove the newline sequence if that sequence is not
(part of) the newline at all. As the \f(CW\*(C`for\*(C'\fR might read broken lines: it
does not care about the quoting. If you need to support embedded newlines,
the way to go is to \fBnot\fR pass \f(CW\*(C`eol\*(C'\fR in the parser (it accepts
\&\f(CW\*(C`\en\*(C'\fR, \f(CW\*(C`\er\*(C'\fR, \fBand\fR \f(CW\*(C`\er\en\*(C'\fR by default) and then
.PP
.Vb 5
\& my $csv = Text::CSV.new;
\& my $io = open $file, :r, :!chomp;
\& while (my $row = $csv.getline($io)) {
\&     my @fields = @$row;
\&     }
.Ve
.SS "Binary data"
.IX Subsection "Binary data"
For now, Text::CSV only accepts Unicode. Binary data is planned.
.SH "SPECIFICATION"
.IX Header "SPECIFICATION"
While no formal specification for \s-1CSV\s0 exists, \s-1RFC 4180\s0 <https://datatracker.ietf.org/doc/html/rfc4180>
(\fI1\fR) describes the common format and establishes  \f(CW\*(C`text/csv\*(C'\fR as the \s-1MIME\s0
type registered with the \s-1IANA.\s0 \s-1RFC 7111\s0 <https://datatracker.ietf.org/doc/html/rfc7111>
(\fI2\fR) adds fragments to \s-1CSV.\s0
.PP
Many informal documents exist that describe the \f(CW\*(C`CSV\*(C'\fR format.   \*(L"How To:
The Comma Separated Value (\s-1CSV\s0) File Format\*(R"
(\fI3\fR)  provides an overview of the  \f(CW\*(C`CSV\*(C'\fR  format in the most widely used
applications and explains how it can best be used and supported.
.PP
.Vb 3
\& 1) https://datatracker.ietf.org/doc/html/rfc4180
\& 2) https://datatracker.ietf.org/doc/html/rfc7111
\& 3) http://creativyst.com/Doc/Articles/CSV/CSV01.shtml
.Ve
.PP
The basic rules are as follows:
.PP
\&\fB\s-1CSV\s0\fR is a delimited data format that has fields/columns separated by the
comma character and records/rows separated by newlines. Fields that contain
a special character (comma, newline, or double quote), must be enclosed in
double quotes. However, if a line contains a single entry that is the empty
string, it may be enclosed in double quotes. If a field's value contains a
double quote character it is escaped by placing another double quote
character next to it. The \f(CW\*(C`CSV\*(C'\fR file format does not require a specific
character encoding, byte order, or line terminator format.
.IP "\(bu" 2
Each record is a single line ended by a line feed (\s-1ASCII/\s0\f(CW\*(C`LF\*(C'\fR=\f(CW0x0A\fR) or
a carriage return and line feed pair (\s-1ASCII/\s0\f(CW\*(C`CRLF\*(C'\fR=\f(CW\*(C`0x0D 0x0A\*(C'\fR), however,
line-breaks may be embedded.
.IP "\(bu" 2
Fields are separated by commas.
.IP "\(bu" 2
Allowable characters within a \f(CW\*(C`CSV\*(C'\fR field include \f(CW0x09\fR (\f(CW\*(C`TAB\*(C'\fR) and the
inclusive range of \f(CW0x20\fR (space) through \f(CW0x7E\fR (tilde). In binary mode
all characters are accepted, at least in quoted fields.
.IP "\(bu" 2
A field within \f(CW\*(C`CSV\*(C'\fR must be surrounded by double-quotes to contain a
separator character (comma).
.PP
Though this is the most clear and restrictive definition, Text::CSV is way
more liberal than this, and allows extension:
.IP "\(bu" 2
Line termination by a single carriage return is accepted by default
.IP "\(bu" 2
The separation, escape, and escape can be any valid Unicode sequence.
.IP "\(bu" 2
A field in \f(CW\*(C`CSV\*(C'\fR must be surrounded by double-quotes to make an embedded
double-quote, represented by a pair of consecutive double-quotes, valid.
You may additionally use the sequence \f(CW\*(C`"0\*(C'\fR for representation of a \s-1NULL\s0
byte. Using \f(CW0x00\fR is just as valid.
.IP "\(bu" 2
Several violations of the above specification may be lifted by passing some
options as attributes to the object constructor.
.SH "METHODS"
.IX Header "METHODS"
.SS "version"
.IX Xref "version"
.IX Subsection "version"
Returns the current module version.
.SS "new"
.IX Xref "new"
.IX Subsection "new"
Returns a new instance of class Text::CSV. The attributes are described by
the optional named parameters
.PP
.Vb 1
\& my $csv = Text::CSV.new(attributes ...);
.Ve
.PP
The following attributes are available:
.IP "eol" 4
.IX Xref "eol"
.IX Item "eol"
.Vb 3
\& my $csv = Text::CSV.new(eol => "\er\en");
\&           $csv.eol(Str);
\& my $eol = $csv.eol;
.Ve
.Sp
The end-of-line string to add to rows for \*(L"print\*(R" or the record separator
for \*(L"getline\*(R".
.Sp
When not set in a \fBparser\fR instance, the default behavior is to accept
\&\f(CW\*(C`\en\*(C'\fR, \f(CW\*(C`\er\*(C'\fR, and \f(CW\*(C`\er\en\*(C'\fR, so it is probably safer to not specify \f(CW\*(C`eol\*(C'\fR at
all. Passing \f(CW\*(C`Str\*(C'\fR or the empty string behave the same.
.Sp
As raku interprets \f(CW\*(C`\er\en\*(C'\fR as a single grapheme in input, it is dissuaded
to use \f(CW\*(C`\er\en\*(C'\fR as \f(CW\*(C`eol\*(C'\fR when parsing. Please choose \f(CW\*(C`Str\*(C'\fR instead.
.Sp
When not passed in a \fBgenerating\fR instance, records are not terminated at
all, so it is probably wise to pass something you expect. A safe choice for
\&\f(CW\*(C`eol\*(C'\fR on output is either \f(CW\*(C`\en\*(C'\fR or \f(CW\*(C`\er\en\*(C'\fR.
.Sp
Common values for \f(CW\*(C`eol\*(C'\fR are \f(CW"\e012"\fR (\f(CW\*(C`\en\*(C'\fR or Line Feed), \f(CW"\e015\e012"\fR
(\f(CW\*(C`\er\en\*(C'\fR or Carriage Return, Line Feed), and \f(CW"\e015"\fR (\f(CW\*(C`\er\*(C'\fR or Carriage
Return).
.IP "sep" 4
.IX Xref "sep"
.IX Item "sep"
.PD 0
.IP "sep_char" 4
.IX Xref "sep_char"
.IX Item "sep_char"
.IP "sep-char" 4
.IX Xref "sep-char"
.IX Item "sep-char"
.IP "separator" 4
.IX Xref "separator"
.IX Item "separator"
.PD
.Vb 3
\& my $csv = Text::CSV.new(sep => ";");
\&           $csv.sep("\ex[ff0c]"); # FULLWIDTH COMMA
\& my $sep = $csv.sep;
.Ve
.Sp
The sequence used to separate fields, by default a comma: (\f(CW\*(C`,\*(C'\fR). This
sequence is required and cannot be disabled.
.Sp
The separation sequence can not be equal to the quote sequence, the
escape sequence or the newline sequence.
.Sp
See also \*(L"\s-1CAVEATS\*(R"\s0
.IP "quote" 4
.IX Xref "quote"
.IX Item "quote"
.PD 0
.IP "quote_char" 4
.IX Xref "quote_char"
.IX Item "quote_char"
.IP "quote-char" 4
.IX Xref "quote-char"
.IX Item "quote-char"
.PD
.Vb 4
\& my $csv = Text::CSV.new(quote => "\*(Aq");
\&           $csv.quote("\ex[ff02]); # FULLWIDTH QUOTATION MARK
\&           $csv.quote(Str);
\& my $quo = $csv.quote;
.Ve
.Sp
The sequence to quote fields containing blanks or binary data, by default
the double quote character (\f(CW\*(C`"\*(C'\fR). A value of \f(CW\*(C`Str\*(C'\fR disables quotation
(for simple cases only).
.Sp
The quotation sequence can not be equal to the separation sequence or the
newline sequence.
.Sp
See also \*(L"\s-1CAVEATS\*(R"\s0
.IP "escape" 4
.IX Xref "escape"
.IX Item "escape"
.PD 0
.IP "escape_char" 4
.IX Xref "escape_char"
.IX Item "escape_char"
.IP "escape-char" 4
.IX Xref "escape-char"
.IX Item "escape-char"
.PD
.Vb 4
\& my $csv = Text::CSV.new(escape => "\e\e");
\&           $csv.escape("\ex[241b]");  # SYMBOL FOR ESCAPE
\&           $csv.escape(Str);
\& my $esc = $csv.escape;
.Ve
.Sp
The sequence to escape certain characters inside quoted fields.
.Sp
The \f(CW\*(C`escape\*(C'\fR defaults to being the double-quote mark (\f(CW\*(C`"\*(C'\fR). In other
words the same as the default sequence for \f(CW\*(C`quote\*(C'\fR. This means
that doubling the quote mark in a field escapes it:
.Sp
.Vb 1
\& "foo","bar","Escape ""quote mark"" with two ""quote marks""","baz"
.Ve
.Sp
If you change \f(CW\*(C`quote\*(C'\fR without changing \f(CW\*(C`escape\*(C'\fR, \f(CW\*(C`escape\*(C'\fR will
still be the double-quote (\f(CW\*(C`"\*(C'\fR). If instead you want to escape
\&\f(CW\*(C`quote\*(C'\fR by doubling it you will need to also change \f(CW\*(C`escape\*(C'\fR to
be the same as what you have changed \f(CW\*(C`quote\*(C'\fR to.
.Sp
The escape sequence can not be equal to the separation sequence.
.IP "binary" 4
.IX Xref "binary"
.IX Item "binary"
\&\s-1WIP:\s0 Default is True. Non\-UTF\-8 real binary (Blob) does not yet parse.
Opening the resource with encoding utf8\-c8 is most likely the way to go.
.Sp
.Vb 3
\& my $csv = Text::CSV.new(:binary);
\&           $csv.binary(False);
\& my $bin = $csv.binary;
.Ve
.Sp
If this attribute is \f(CW\*(C`True\*(C'\fR, you may use binary data in quoted fields,
including line feeds, carriage returns and \f(CW\*(C`NULL\*(C'\fR bytes. (The latter could
be escaped as \f(CW\*(C`"0\*(C'\fR.) By default this feature is on.
.Sp
Note that valid Unicode (\s-1UTF\-8\s0) is not considered binary.
.IP "strict" 4
.IX Xref "strict"
.IX Item "strict"
.Vb 3
\& my $csv = Text::CSV.new(:strict);
\&           $csv.strict(False);
\& my $flg = $csv.strict;
.Ve
.Sp
If set to True, any row that parses to a different number of columns than
the previous row will cause the parser to throw error 2014.
.IP "formula-handling" 4
.IX Xref "formula-handling"
.IX Item "formula-handling"
.PD 0
.IP "formula_handling" 4
.IX Xref "formula_handling"
.IX Item "formula_handling"
.IP "formula" 4
.IX Xref "formula"
.IX Item "formula"
.PD
.Vb 3
\& my $csv = Text::CSV.new(formula => "none");
\&         $csv.formula("none");
\& my $f = $csv.formula;
.Ve
.Sp
This defines the behavior of fields containing \fIformulas\fR. As formulas are
considered dangerous in spreadsheets, this attribute can define an optional
action to be taken if a field starts with an equal sign (\f(CW\*(C`=\*(C'\fR).
.Sp
For purpose of code-readability, this can also be written as
.Sp
.Vb 3
\& my $csv = Text::CSV_XS.new(formula\-handling => "none"});
\&         $csv.formula\-handling("none");
\& my $f = $csv.formula\-handling;
.Ve
.Sp
or
.Sp
.Vb 3
\& my $csv = Text::CSV_XS.new(formula_handling => "none"});
\&         $csv.formula_handling("none");
\& my $f = $csv.formula_handling;
.Ve
.Sp
Possible values for this attribute are
.RS 4
.IP "none" 2
.IX Item "none"
Take no specific action. This is the default.
.Sp
.Vb 1
\& $csv.formula("none");
.Ve
.IP "die" 2
.IX Item "die"
Cause the process to \f(CW\*(C`die\*(C'\fR whenever a leading \f(CW\*(C`=\*(C'\fR is encountered.
.Sp
.Vb 1
\& $csv.formula("die");
.Ve
.IP "croak" 2
.IX Item "croak"
Cause the process to \f(CW\*(C`die\*(C'\fR whenever a leading \f(CW\*(C`=\*(C'\fR is encountered.
.Sp
.Vb 1
\& $csv.formula("croak");
.Ve
.Sp
This option just exists for perl5 compatibility.
.IP "diag" 2
.IX Item "diag"
Report position and content of the field whenever a leading \f(CW\*(C`=\*(C'\fR is found.
The value of the field is unchanged.
.Sp
.Vb 1
\& $csv.formula("diag");
.Ve
.IP "empty" 2
.IX Item "empty"
Replace the content of fields that start with a \f(CW\*(C`=\*(C'\fR with the empty string.
.Sp
.Vb 2
\& $csv.formula("empty");
\& $csv.formula("");
.Ve
.IP "undef" 2
.IX Item "undef"
Replace the content of fields that start with a \f(CW\*(C`=\*(C'\fR with \f(CW\*(C`Str\*(C'\fR.
.Sp
.Vb 2
\& $csv.formula("undef");
\& $csv.formula(Str);
.Ve
.RE
.RS 4
.Sp
All other values will throw an exception with error code 1500.
.RE
.IP "auto_diag" 4
.IX Xref "auto_diag"
.IX Item "auto_diag"
.PD 0
.IP "auto-diag" 4
.IX Xref "auto-diag"
.IX Item "auto-diag"
.PD
.Vb 3
\& my $csv = Text::CSV.new(auto_diag => False);
\&           $csv.auto_diag(True);
\& my $a\-d = $csv.auto_diag;
.Ve
.Sp
Set this attribute to a number between \f(CW1\fR and \f(CW9\fR causes \*(L"error_diag\*(R"
to be automatically called in void context upon errors. The value \f(CW\*(C`True\*(C'\fR
evaluates to \f(CW1\fR.
.Sp
In case of error \f(CW\*(C`2012 \- EOF\*(C'\fR, this call will be void.
.Sp
If \f(CW\*(C`auto_diag\*(C'\fR is set to a numeric value greater than \f(CW1\fR, it will \f(CW\*(C`die\*(C'\fR
on errors instead of \f(CW\*(C`warn\*(C'\fR.
.IP "diag_verbose" 4
.IX Xref "diag_verbose"
.IX Item "diag_verbose"
.PD 0
.IP "diag-verbose" 4
.IX Xref "diag-verbose"
.IX Item "diag-verbose"
.PD
.Vb 3
\& my $csv = Text::CSV.new(diag_verbose => 1);
\&           $csv.diag_verbose(2);
\& my $d\-v = $csv.diag_verbose;
.Ve
.Sp
Set the verbosity of the output triggered by \f(CW\*(C`auto_diag\*(C'\fR.
.Sp
\&\s-1WIP:\s0 Does not add any information yet.
.IP "blank_is_undef" 4
.IX Xref "blank_is_undef"
.IX Item "blank_is_undef"
.PD 0
.IP "blank-is-undef" 4
.IX Xref "blank-is-undef"
.IX Item "blank-is-undef"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:blank_is_undef);
\&           $csv.blank_is_undef(False);
\& my $biu = $csv.blank_is_undef;
.Ve
.Sp
Under normal circumstances, \f(CW\*(C`CSV\*(C'\fR data makes no distinction between quoted\-
and unquoted empty fields. These both end up in an empty string field once
read, thus
.Sp
.Vb 1
\& 1,"",," ",2
.Ve
.Sp
is read as
.Sp
.Vb 1
\& [ "1", "", "", " ", "2" ]
.Ve
.Sp
When \fIwriting\fR \f(CW\*(C`CSV\*(C'\fR files with \f(CW\*(C`always_quote\*(C'\fR set, the
unquoted \fIempty\fR field is the result of an undefined value. To enable this
distinction when \fIreading\fR \f(CW\*(C`CSV\*(C'\fR data, the \f(CW\*(C`blank_is_undef\*(C'\fR attribute
will cause unquoted empty fields to be set to \f(CW\*(C`Str\*(C'\fR, causing the above
to be parsed as
.Sp
.Vb 1
\& [ "1", "", Str, " ", "2" ]
.Ve
.IP "empty_is_undef" 4
.IX Xref "empty_is_undef"
.IX Item "empty_is_undef"
.PD 0
.IP "empty-is-undef" 4
.IX Xref "empty-is-undef"
.IX Item "empty-is-undef"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:empty_is_undef);
\&           $csv.empty_is_undef(False);
\& my $eiu = $csv.empty_is_undef;
.Ve
.Sp
Going one step further than \f(CW\*(C`blank_is_undef\*(C'\fR, this
attribute causes all empty fields to return as \f(CW\*(C`Str\*(C'\fR, so
.Sp
.Vb 1
\& 1,"",," ",2
.Ve
.Sp
is read as
.Sp
.Vb 1
\& [ 1, Str, Str, " ", 2 ]
.Ve
.Sp
Note that this effects only fields that are originally empty, not fields
that are empty after stripping allowed whitespace. \s-1YMMV.\s0
.IP "allow_whitespace" 4
.IX Xref "allow_whitespace"
.IX Item "allow_whitespace"
.PD 0
.IP "allow-whitespace" 4
.IX Xref "allow-whitespace"
.IX Item "allow-whitespace"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:allow_whitespace);
\&           $csv.allow_whitespace(False);
\& my $a\-w = $csv.allow_whitespace;
.Ve
.Sp
When this option is set to \f(CW\*(C`True\*(C'\fR, the whitespace (\f(CW\*(C`TAB\*(C'\fR's and \f(CW\*(C`SPACE\*(C'\fR's)
surrounding the separation sequence is removed when parsing. If either
\&\f(CW\*(C`TAB\*(C'\fR or \f(CW\*(C`SPACE\*(C'\fR is one of the three major sequences \f(CW\*(C`sep\*(C'\fR,
\&\f(CW\*(C`quote\*(C'\fR, or \f(CW\*(C`escape\*(C'\fR it will not be considered
whitespace.
.Sp
Now lines like:
.Sp
.Vb 1
\& 1 , "foo" , bar , 3 , zapp
.Ve
.Sp
are parsed as valid \f(CW\*(C`CSV\*(C'\fR, even though it violates the \f(CW\*(C`CSV\*(C'\fR specs.
.Sp
Note that \fBall\fR whitespace is stripped from both start and end of each
field. That would make it \fImore\fR than a \fIfeature\fR to enable parsing bad
\&\f(CW\*(C`CSV\*(C'\fR lines, as
.Sp
.Vb 1
\& 1,   2.0,  3,   ape  , monkey
.Ve
.Sp
will now be parsed as
.Sp
.Vb 1
\& [ "1", "2.0", "3", "ape", "monkey" ]
.Ve
.Sp
even if the original line was perfectly acceptable \f(CW\*(C`CSV\*(C'\fR.
.IP "allow_loose_quotes" 4
.IX Xref "allow_loose_quotes"
.IX Item "allow_loose_quotes"
.PD 0
.IP "allow-loose-quotes" 4
.IX Xref "allow-loose-quotes"
.IX Item "allow-loose-quotes"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:allow_loose_quotes);
\&           $csv.allow_loose_quotes(False);
\& my $alq = $csv.allow_loose_quotes;
.Ve
.Sp
By default, parsing unquoted fields containing \f(CW\*(C`quote\*(C'\fR's like
.Sp
.Vb 1
\& 1,foo "bar" baz,42
.Ve
.Sp
would result in parse error 2034. Though it is still bad practice to allow
this format, we cannot help the fact that some vendors make their
applications spit out lines styled this way.
.Sp
If there is \fBreally\fR bad \f(CW\*(C`CSV\*(C'\fR data, like
.Sp
.Vb 1
\& 1,"foo "bar" baz",42
.Ve
.Sp
or
.Sp
.Vb 1
\& 1,""foo bar baz"",42
.Ve
.Sp
there is a way to get this data-line parsed and leave the quotes inside the
quoted field as-is. This can be achieved by setting \f(CW\*(C`allow_loose_quotes\*(C'\fR
\&\fB\s-1AND\s0\fR making sure that the \f(CW\*(C`escape\*(C'\fR is \fInot\fR equal to
\&\f(CW\*(C`quote\*(C'\fR.
.IP "allow_loose_escapes" 4
.IX Xref "allow_loose_escapes"
.IX Item "allow_loose_escapes"
.PD 0
.IP "allow-loose-escapes" 4
.IX Xref "allow-loose-escapes"
.IX Item "allow-loose-escapes"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:allow_loose_escapes);
\&           $csv.allow_loose_escapes(False);
\& my $ale = $csv.allow_loose_escapes;
.Ve
.Sp
Parsing fields that have \f(CW\*(C`escape\*(C'\fR sequences that escape
characters that do not need to be escaped, like:
.Sp
.Vb 2
\& my $csv = Text::CSV.new(escape_char => "\e\e");
\& $csv.parse(q{1,"my bar\e\*(Aqs",baz,42});
.Ve
.Sp
would result in parse returning \f(CW\*(C`False\*(C'\fR with reason 2025. Though it is bad
practice to allow this format, this attribute enables you to treat all
escape sequences equal.
.IP "allow_unquoted_escape" 4
.IX Xref "allow_unquoted_escape"
.IX Item "allow_unquoted_escape"
.PD 0
.IP "allow-unquoted-escape" 4
.IX Xref "allow-unquoted-escape"
.IX Item "allow-unquoted-escape"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:allow_unquoted_escape);
\&           $csv.allow_unquoted_escape(False);
\& my $aue = $csv.allow_unquoted_escape;
.Ve
.Sp
A backward compatibility issue where \f(CW\*(C`escape\*(C'\fR differs from
\&\f(CW\*(C`quote\*(C'\fR prevents \f(CW\*(C`escape\*(C'\fR to be in the first
position of a field. If \f(CW\*(C`quote\*(C'\fR is equal to the default \f(CW\*(C`"\*(C'\fR and
\&\f(CW\*(C`escape\*(C'\fR is set to \f(CW\*(C`\e\*(C'\fR, this would be illegal:
.Sp
.Vb 1
\& 1,\e0,2
.Ve
.Sp
Setting this attribute to \f(CW\*(C`True\*(C'\fR might help to overcome issues with
backward compatibility and allow this style.
.IP "always_quote" 4
.IX Xref "always_quote"
.IX Item "always_quote"
.PD 0
.IP "always-quote" 4
.IX Xref "always-quote"
.IX Item "always-quote"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:always_quote);
\&         $csv.always_quote(False);
\& my $f = $csv.always_quote;
.Ve
.Sp
By default the generated fields are quoted only if they \fIneed\fR to be. For
example, if they contain the separator sequence. If you set this attribute
to \f(CW1\fR then \fIall\fR defined fields will be quoted. (undefined (\f(CW\*(C`Str\*(C'\fR)
fields are not quoted, see \*(L"blank_is_undef\*(R"). This makes it quite often
easier to handle exported data in external applications. (Poor creatures
who are better to use Text::CSV. :)
.IP "quote_empty" 4
.IX Xref "quote_empty"
.IX Item "quote_empty"
.PD 0
.IP "quote-empty" 4
.IX Xref "quote-empty"
.IX Item "quote-empty"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:quote_empty);
\&           $csv.quote_empty(False);
\& my $q\-s = $csv.quote_empty;
.Ve
.Sp
By default the generated fields are quoted only if they \fIneed\fR to be. An
empty defined field does not need quotation. If you set this attribute to
\&\f(CW\*(C`True\*(C'\fR then empty defined fields will be quoted. See also
\&\f(CW\*(C`always_quote\*(C'\fR.
.IP "quote_space" 4
.IX Xref "quote_space"
.IX Item "quote_space"
.PD 0
.IP "quote-space" 4
.IX Xref "quote-space"
.IX Item "quote-space"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:quote_space);
\&           $csv.quote_space(False);
\& my $q\-s = $csv.quote_space;
.Ve
.Sp
By default, a space in a field would trigger quotation. As no rule exists
this to be forced in \f(CW\*(C`CSV\*(C'\fR, nor any for the opposite, the default is
\&\f(CW\*(C`True\*(C'\fR for safety. You can exclude the space from this trigger by setting
this attribute to \f(CW\*(C`False\*(C'\fR.
.IP "escape_null" 4
.IX Xref "escape_null"
.IX Item "escape_null"
.PD 0
.IP "quote-null" 4
.IX Xref "quote-null"
.IX Item "quote-null"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:escape_null);
\&           $csv.escape_null(False);
\& my $q\-n = $csv.escape_null;
.Ve
.Sp
By default, a \f(CW\*(C`NULL\*(C'\fR byte in a field would be escaped. This option enables
you to treat the \f(CW\*(C`NULL\*(C'\fR byte as a simple binary character in binary mode
(the \f(CW\*(C`binary => True\*(C'\fR is set). The default is \f(CW\*(C`True\*(C'\fR. You can prevent
\&\f(CW\*(C`NULL\*(C'\fR escapes by setting this attribute to \f(CW\*(C`False\*(C'\fR.
.IP "quote_binary" 4
.IX Xref "quote_binary"
.IX Item "quote_binary"
.PD 0
.IP "quote-binary" 4
.IX Xref "quote-binary"
.IX Item "quote-binary"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:quote_binary);
\&           $csv.quote_binary(False);
\& my $q\-b = $csv.quote_binary;
.Ve
.Sp
By default, all \*(L"unsafe\*(R" bytes inside a string cause the combined field to
be quoted. By setting this attribute to \f(CW\*(C`False\*(C'\fR, you can disable that
trigger for bytes >= \f(CW0x7F\fR. (\s-1WIP\s0)
.IP "keep_meta" 4
.IX Xref "keep_meta"
.IX Item "keep_meta"
.PD 0
.IP "keep-meta" 4
.IX Xref "keep-meta"
.IX Item "keep-meta"
.PD
.Vb 3
\& my $csv = Text::CSV.new(:keep_meta);
\&           $csv.keep_meta(False);
\& my $k\-m = $csv.keep_meta_info;
.Ve
.Sp
By default, the parsing of input records is as simple and fast as possible.
However, some parsing information \- like quotation of the original field \-
is lost in that process. Setting this flag to true enables retrieving that
information after parsing with the methods \*(L"meta_info\*(R", \*(L"is_quoted\*(R",
and \*(L"is_binary\*(R" described below. Default is \f(CW\*(C`False\*(C'\fR for ease of use.
.Sp
If \f(CW\*(C`keep\-meta\*(C'\fR is set to \f(CW\*(C`True\*(C'\fR, the returned fields are not of type
\&\f(CW\*(C`Str\*(C'\fR but of type \f(CW\*(C`CSV::Field\*(C'\fR.
.IP "undef_str" 4
.IX Xref "undef_str"
.IX Item "undef_str"
.PD 0
.IP "undef-str" 4
.IX Xref "undef-str"
.IX Item "undef-str"
.PD
\&\s-1NYI\s0 \- this should replace undefined values in generating \s-1CSV\s0
.IP "comment_str" 4
.IX Xref "comment_str"
.IX Item "comment_str"
.PD 0
.IP "comment-str" 4
.IX Xref "comment-str"
.IX Item "comment-str"
.PD
.Vb 3
\& my $csv = Text::CSV.new(comment_str => "#");
\&         $csv.comment_str (Str);
\& my $s = $csv.comment_str;
.Ve
.Sp
This attribute optionally defines a string to be recognized as comment. If
this attribute is defined, all lines starting with this sequence will not
be parsed as \s-1CSV\s0 but skipped as comment.
.Sp
This attribute has no meaning when generating \s-1CSV.\s0
.IP "types" 4
.IX Item "types"
\&\s-1NYI\s0
.Sp
A set of column types; the attribute is immediately passed to the \*(L"types\*(R"
method.
.IP "callbacks" 4
.IX Xref "callbacks"
.IX Item "callbacks"
See the \*(L"Callbacks\*(R" section below.
.PP
To sum it up,
.PP
.Vb 1
\& $csv = Text::CSV.new;
.Ve
.PP
is equivalent to
.PP
.Vb 10
\& $csv = Text::CSV.new(
\&     eol                   => Nil, # \er, \en, or \er\en
\&     sep                   => \*(Aq,\*(Aq,
\&     quote                 => \*(Aq"\*(Aq,
\&     escape                => \*(Aq"\*(Aq,
\&     binary                => True,
\&     auto\-diag             => False,
\&     diag\-verbose          => 0,
\&     blank\-is\-undef        => False,
\&     empty\-is\-undef        => False,
\&     allow\-whitespace      => False,
\&     allow\-loose\-quotes    => False,
\&     allow\-loose\-escapes   => False,
\&     allow\-unquoted\-escape => False,
\&     always\-quote          => False,
\&     quote\-space           => True,
\&     escape\-null           => True,
\&     quote\-binary          => True,
\&     keep\-meta             => False,
\&     strict                => False,
\&     formula               => "none",
\&     undef\-str             => Str,
\&     comment\-str           => Str,
\&     types                 => Nil,
\&     callbacks             => Nil,
\&     });
.Ve
.PP
For all of the above mentioned flags, an accessor method is available where
you can inquire the current value, or change the value
.PP
.Vb 2
\& my $quote = $csv.quote;
\& $csv.binary(True);
.Ve
.PP
It is not wise to change these settings halfway through writing \f(CW\*(C`CSV\*(C'\fR data
to a stream. If however you want to create a new stream using the available
\&\f(CW\*(C`CSV\*(C'\fR object, there is no harm in changing them.
.PP
If the \*(L"new\*(R" constructor call fails, an exception of type \f(CW\*(C`CSV::Diac\*(C'\fR is
thrown with the reason like the \*(L"error_diag\*(R" method would return:
.PP
.Vb 5
\& my $e;
\& {   $csv = Text::CSV.new(ecs_char => ":") or
\&     CATCH { default { $e = $_; }}
\&     }
\& $e and $e.message.say;
.Ve
.PP
The message will be a string like
.PP
.Vb 1
\& "INI \- Unknown attribute \*(Aqecs_char\*(Aq"
.Ve
.SS "print"
.IX Xref "print"
.IX Subsection "print"
.Vb 4
\& $status = $csv.print($io,  $fld, ... );
\& $status = $csv.print($io, ($fld, ...));
\& $status = $csv.print($io, [$fld, ...]);
\& $status = $csv.print($io,  @fld      );
\&
\& $csv.column_names(%fld.keys); # or use a subset
\& $status = $csv.print($io,  %fld      );
.Ve
.PP
Similar to \*(L"combine\*(R" + \*(L"string\*(R" + \*(L"print\*(R", but much more efficient.
It takes an \s-1IO\s0 object and any number of arguments interpreted as fields.
The resulting string is immediately written to the \f(CW$io\fR stream.
.PP
\&\s-1NYI:\s0 no fields in combination with \*(L"bind_columns\*(R", like
.PP
.Vb 2
\& $csv.bind_columns(\e($foo, $bar));
\& $status = $csv.print($fh);
.Ve
.PP
A benchmark showed this order of preference, but the difference is within
noise range:
.PP
.Vb 5
\& my @data = ^20;
\& $csv.print($io,   @data  );   # 2.6 sec
\& $csv.print($io, [ @data ]);   # 2.7 sec
\& $csv.print($io,    ^20   );   # 2.7 sec
\& $csv.print($io,  \e@data  );   # 2.8 sec
.Ve
.SS "say"
.IX Xref "say"
.IX Subsection "say"
Is the same a s\*(L"print\*(R" where \f(CW\*(C`eol\*(C'\fR defaults to \f(CW\*(C`$*OUT.nl\*(C'\fR.
.PP
.Vb 4
\& $status = $csv.say($io,  $fld, ... );
\& $status = $csv.say($io, ($fld, ...));
\& $status = $csv.say($io, [$fld, ...]);
\& $status = $csv.say($io,  @fld      );
\&
\& $csv.column_names(%fld.keys); # or use a subset
\& $status = $csv.say($io,  %fld      );
.Ve
.SS "combine"
.IX Xref "combine"
.IX Subsection "combine"
.Vb 3
\& $status = $csv.combine(@fields);
\& $status = $csv.combine($fld, ...);
\& $status = $csv.combine(\e@fields);
.Ve
.PP
This method constructs a \f(CW\*(C`CSV\*(C'\fR row from \f(CW@fields\fR, returning success or
failure. Failure can result from lack of arguments or an argument that
contains invalid data. Upon success, \*(L"string\*(R" can be called to retrieve
the resultant \f(CW\*(C`CSV\*(C'\fR string. Upon failure, the value returned by \*(L"string\*(R"
is undefined and \*(L"error_input\*(R" could be called to retrieve the invalid
argument. (\s-1WIP\s0)
.SS "string"
.IX Xref "string"
.IX Subsection "string"
.Vb 1
\& $line = $csv.string;
.Ve
.PP
This method returns the input to \*(L"parse\*(R" or the resultant \f(CW\*(C`CSV\*(C'\fR string
of \*(L"combine\*(R", whichever was called more recently. If \f(CW\*(C`eol\*(C'\fR is
defined, it is added to the string.
.SS "getline"
.IX Xref "getline"
.IX Subsection "getline"
.Vb 4
\& @row = $csv.getline($io);
\& @row = $csv.getline($io,  :meta);
\& @row = $csv.getline($str);
\& @row = $csv.getline($str, :meta);
.Ve
.PP
This is the counterpart to \*(L"print\*(R", as \*(L"parse\*(R" is the counterpart to
\&\*(L"combine\*(R": it parses a row from the \f(CW$io\fR handle or \f(CW$str\fR using the
\&\*(L"getline\*(R" method associated with \f(CW$io\fR (or the internal temporary \s-1IO\s0
handle used to read from the string as if it were an \s-1IO\s0 handle) and parses
this row into an array. This array is returned by the function or \f(CW\*(C`Array\*(C'\fR
for failure. When \f(CW$io\fR does not support \f(CW\*(C`getline\*(C'\fR, you are likely to hit
errors.
.PP
\&\s-1NYI:\s0 When fields are bound with \*(L"bind_columns\*(R" the return value is a
reference to an empty list.
.SS "getline_all =head2 getline-all"
.IX Xref "getline_all getline-all"
.IX Subsection "getline_all =head2 getline-all"
.Vb 6
\& @rows = $csv.getline_all($io);
\& @rows = $csv.getline_all($io,                   :meta);
\& @rows = $csv.getline_all($io, $offset);
\& @rows = $csv.getline_all($io, $offset,          :meta);
\& @rows = $csv.getline_all($io, $offset, $length);
\& @rows = $csv.getline_all($io, $offset, $length, :meta);
.Ve
.PP
This will return a list of getline($io) results.
If \f(CW$offset\fR is negative, as with \f(CW\*(C`splice\*(C'\fR, only the last \f(CW\*(C`abs($offset)\*(C'\fR
records of \f(CW$io\fR are taken into consideration.
.PP
Given a \s-1CSV\s0 file with 10 lines:
.PP
.Vb 10
\& lines call
\& \-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& 0..9  $csv.getline_all($io)         # all
\& 0..9  $csv.getline_all($io,  0)     # all
\& 8..9  $csv.getline_all($io,  8)     # start at 8
\& \-     $csv.getline_all($io,  0,  0) # start at 0 first 0 rows
\& 0..4  $csv.getline_all($io,  0,  5) # start at 0 first 5 rows
\& 4..5  $csv.getline_all($io,  4,  2) # start at 4 first 2 rows
\& 8..9  $csv.getline_all($io, \-2)     # last 2 rows
\& 6..7  $csv.getline_all($io, \-4,  2) # first 2 of last  4 rows
.Ve
.SS "getline_hr =head2 getline-hr"
.IX Xref "getline_hr getline-hr"
.IX Subsection "getline_hr =head2 getline-hr"
The \*(L"getline_hr\*(R" and \*(L"column_names\*(R" methods work together to allow you
to have rows returned as hashes instead of arrays. You must invoke
\&\*(L"column_names\*(R" first to declare your column names.
.PP
.Vb 4
\& $csv.column_names(< code name price description >);
\& %hr = $csv.getline_hr($str, :meta);
\& %hr = $csv.getline_hr($io);
\& say "Price for %hr<name> is %hr<price> \ec[EURO SIGN]";
.Ve
.PP
\&\*(L"getline_hr\*(R" will fail if invoked before \*(L"column_names\*(R".
.SS "getline_hr_all =head2 getline-hr-all"
.IX Xref "getline_hr_all getline-hr-all"
.IX Subsection "getline_hr_all =head2 getline-hr-all"
.Vb 6
\& @rows = $csv.getline_hr_all($io);
\& @rows = $csv.getline_hr_all($io,                   :meta);
\& @rows = $csv.getline_hr_all($io, $offset);
\& @rows = $csv.getline_hr_all($io, $offset,          :meta);
\& @rows = $csv.getline_hr_all($io, $offset, $length);
\& @rows = $csv.getline_hr_all($io, $offset, $length, :meta);
.Ve
.PP
This will return a list of getline_hr($io) results.
.SS "parse"
.IX Xref "parse"
.IX Subsection "parse"
.Vb 1
\& $status = $csv.parse($line);
.Ve
.PP
This method decomposes a \f(CW\*(C`CSV\*(C'\fR string into fields, returning success or
failure. Failure can result from a lack of argument or improper format in
the given \f(CW\*(C`CSV\*(C'\fR string. Upon success, invoke \*(L"fields\*(R" or \*(L"strings\*(R" to
get the decomposed fields. Upon failure these methods shall not be trusted
to return reliable data.
.PP
\&\s-1NYI:\s0 You may use the \*(L"types\*(R" method for setting column types. See
\&\*(L"types\*(R"' description below.
.SS "fragment"
.IX Xref "fragment"
.IX Subsection "fragment"
This function implements \s-1RFC7111\s0 <https://datatracker.ietf.org/doc/html/rfc7111>
(\s-1URI\s0 Fragment Identifiers for the text/csv Media Type).
.PP
.Vb 1
\& my @rows = $csv.fragment($io, $spec);
.Ve
.PP
In specifications, \f(CW\*(C`*\*(C'\fR is used to specify the \fIlast\fR item, a dash (\f(CW\*(C`\-\*(C'\fR)
to indicate a range. All indices are \f(CW1\fR\-based: the first row or column
has index \f(CW1\fR. Selections can be combined with the semi-colon (\f(CW\*(C`;\*(C'\fR).
.PP
When using this method in combination with \*(L"column_names\*(R", the returned
array will be a list of hashes instead of an array of arrays. A disjointed
cell-based combined selection might return rows with different number of
columns making the use of hashes unpredictable.
.PP
.Vb 2
\& $csv.column_names(< Name Age >);
\& my @rows = $csv.fragment($io, "row=3;8");
.Ve
.PP
Note that for \f(CW\*(C`col=".."\*(C'\fR, the column names are the names for \fIbefore\fR the
selection is taken to make it more consistent with reading possible headers
from the first line of the \s-1CSV\s0 datastream.
.PP
.Vb 2
\& $csv,column_names(< foo bar >);  # WRONG
\& $csv.fragment($io, "col=3");
.Ve
.PP
would set the column names for the first two columns that are then skipped
in the fragment. To skip the unwanted columns, use placeholders.
.PP
.Vb 2
\& $csv.column_names(< x x Name >);
\& $csv.fragment($io, "col=3");
.Ve
.PP
\&\s-1WIP:\s0 If the \*(L"after_parse\*(R" callback is active, it is also called on every
line parsed and skipped before the fragment.
.IP "row" 2
.IX Item "row"
.Vb 4
\& row=4
\& row=5\-7
\& row=6\-*
\& row=1\-2;4;6\-*
.Ve
.IP "col" 2
.IX Item "col"
.Vb 4
\& col=2
\& col=1\-3
\& col=4\-*
\& col=1\-2;4;7\-*
.Ve
.IP "cell" 2
.IX Item "cell"
In cell-based selection, the comma (\f(CW\*(C`,\*(C'\fR) is used to pair row and column
.Sp
.Vb 1
\& cell=4,1
.Ve
.Sp
The range operator (\f(CW\*(C`\-\*(C'\fR) using \f(CW\*(C`cell\*(C'\fRs can be used to define top-left and
bottom-right \f(CW\*(C`cell\*(C'\fR location
.Sp
.Vb 1
\& cell=3,1\-4,6
.Ve
.Sp
The \f(CW\*(C`*\*(C'\fR is only allowed in the second part of a pair
.Sp
.Vb 3
\& cell=3,2\-*,2    # row 3 till end, only column 2
\& cell=3,2\-3,*    # column 2 till end, only row 3
\& cell=3,2\-*,*    # strip row 1 and 2, and column 1
.Ve
.Sp
Cells and cell ranges may be combined with \f(CW\*(C`;\*(C'\fR, possibly resulting in rows
with different number of columns
.Sp
.Vb 1
\& cell=1,1\-2,2;3,3\-4,4;1,4;4,1
.Ve
.Sp
Disjointed selections will only return selected cells. The cells that are
not specified will not be included in the returned set, not even as
\&\f(CW\*(C`Str\*(C'\fR. As an example given a \f(CW\*(C`CSV\*(C'\fR like
.Sp
.Vb 4
\& 11,12,13,...19
\& 21,22,...28,29
\& :            :
\& 91,...97,98,99
.Ve
.Sp
with \f(CW\*(C`cell=1,1\-2,2;3,3\-4,4;1,4;4,1\*(C'\fR will return:
.Sp
.Vb 4
\& 11,12,14
\& 21,22
\& 33,34
\& 41,43,44
.Ve
.Sp
Overlapping cell-specs will return those cells only once, So
\&\f(CW\*(C`cell=1,1\-3,3;2,2\-4,4;2,3;4,2\*(C'\fR will return:
.Sp
.Vb 4
\& 11,12,13
\& 21,22,23,24
\& 31,32,33,34
\& 42,43,44
.Ve
.PP
\&\s-1RFC7111\s0 <https://datatracker.ietf.org/doc/html/rfc7111> does \fBnot\fR allow different
types of specs to be combined (either \f(CW\*(C`row\*(C'\fR \fIor\fR \f(CW\*(C`col\*(C'\fR \fIor\fR \f(CW\*(C`cell\*(C'\fR).
Passing an invalid fragment specification will croak and set error 2013.
.PP
Using \*(L"colrange\*(R" and \*(L"rowrange\*(R" instead of \*(L"fragment\*(R" will allow you
to combine row\- and column selecting as a grid.
.SS "colrange"
.IX Xref "colrange"
.IX Subsection "colrange"
.Vb 4
\& my Int @range = ^5, 5..9;
\& $csv.colrange(@range);
\& $csv.colrange("0\-4;6\-10");
\& my @range = $csv.colrange;
.Ve
.PP
Set or inspect the column ranges. When passed as an array of \f(CW\*(C`Int\*(C'\fR, the
indexes are 0\-based. When passed as a string, the syntax of the range is as
defined by \s-1RFC7111\s0 and thus 1\-based.
.SS "rowrange"
.IX Xref "rowrange"
.IX Subsection "rowrange"
.Vb 2
\& $csv.rowrange("1;16\-*");
\& my @r = $csv.rowrange;
.Ve
.PP
Set or inspect the row ranges. Only supports \s-1RFC7111\s0 style.
Indexes are 1\-based.
.SS "column_names =head2 column-names"
.IX Xref "column_names column-names"
.IX Subsection "column_names =head2 column-names"
Set the \*(L"keys\*(R" that will be used in the \*(L"getline_hr\*(R" calls. If no keys
(column names) are passed, it will return the current setting as a list.
.PP
.Vb 2
\& $csv.column_names(< code description price >);
\& my @names = $csv.column_names;
.Ve
.PP
\&\*(L"column_names\*(R" accepts a list of strings (the column names) or a single
array with the names. You can pass the return value from \*(L"getline\*(R" too:
.PP
.Vb 1
\& $csv.column_names($csv.getline($io));
.Ve
.PP
\&\*(L"column_names\*(R" does \fBno\fR checking on duplicates at all, which might lead
to unexpected results. As raku does not accept undefined keys in a hash,
passing just types will lead to fail later on.
.PP
.Vb 3
\& $csv.column_names(Str, "", "name"); # Will FAIL becaus of Str
\& $csv.column_names(< code name count name >); # will drop the second column
\& %hr = $csv.getline_hr($io);
.Ve
.SS "header"
.IX Subsection "header"
Parse the \s-1CSV\s0 header and set \f(CW\*(C`sep\*(C'\fR and encoding.
.PP
.Vb 3
\& my @hdr = $csv.header($fh).column\-names;
\& $csv.header($fh, sep\-set => [ ";", ",", "|", "\et" ]);
\& $csv.header($fh, munge\-column\-names => "fc");
.Ve
.PP
The first argument should be a file handle.
.PP
Assuming that the file opened for parsing has a header, and the header does
not contain problematic characters like embedded newlines, read the first
line from the open handle then auto-detect whether the header separates the
column names with a character from the allowed separator list.
.PP
If any of the allowed separators matches, and none of the \fIother\fR allowed
separators match, set \f(CW\*(C`sep\*(C'\fR to that separator for the current
\&\s-1CSV_XS\s0 instance and use it to parse the first line, map those to lowercase,
and use that to set the instance \*(L"column_names\*(R":
.PP
.Vb 6
\& my $csv = Text::CSV.new;
\& my $fh = open "file.csv";
\& $csv.header($fh);
\& while (my $row = $csv.getline_hr($fh)) {
\&     ...
\&     }
.Ve
.PP
If the header is empty, contains more than one unique separator out of the
allowed set, contains empty fields, or contains identical fields (after
folding), it will croak with error 1010, 1011, 1012, or 1013 respectively.
.PP
If the header contains embedded newlines or is not valid \s-1CSV\s0 in any other
way, this method will throw an exception.
.PP
A successful call to \f(CW\*(C`header\*(C'\fR will always set the \f(CW\*(C`sep\*(C'\fR of the
\&\f(CW$csv\fR object. This behavior can not be disabled.
.PP
\fIreturn value\fR
.IX Subsection "return value"
.PP
On error this method will throw an exception.
.PP
On success, this method will return the instance.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "sep-set" 2
.IX Item "sep-set"
.Vb 1
\& $csv.header($fh, sep_set => [ ";", ",", "|", "\et" ]);
.Ve
.Sp
The list of legal separators defaults to \f(CW\*(C`[ ";", "," ]\*(C'\fR and can be changed
by this option.
.Sp
Multi-byte sequences are allowed, both multi-character and Unicode. See
\&\f(CW\*(C`sep\*(C'\fR.
.IP "munge-column-names" 2
.IX Item "munge-column-names"
This option offers the means to modify the column names into something that
is most useful to the application. The default is to map all column names
to fold case.
.Sp
.Vb 1
\& $csv.header($fh, munge\-column\-names => "lc");
.Ve
.Sp
The following values are available:
.Sp
.Vb 5
\&  fc   \- fold case
\&  lc   \- lower case
\&  uc   \- upper case
\&  none \- do not change
\&  &cb  \- supply a callback
\&
\& $csv.header($fh, munge\-column\-names => { "column_".$col++ });
.Ve
.IP "set-column-names" 2
.IX Item "set-column-names"
.Vb 1
\& $csv.header($fh, :set\-column\-names);
.Ve
.Sp
The default is to set the instances column names using \*(L"column_names\*(R" if
the method is successful, so subsequent calls to \*(L"getline_hr\*(R" can return
a hash. Disable setting the header can be forced using a false value for
this option like \f(CW\*(C`:!set\-column\-names\*(C'\fR.
.SS "bind_columns =head2 bind-columns"
.IX Xref "bind_columns bind-columns"
.IX Subsection "bind_columns =head2 bind-columns"
\&\s-1NYI\s0!
.PP
Takes a list of scalar references to be used for output with \*(L"print\*(R" or
to store in the fields fetched by \*(L"getline\*(R". When you do not pass enough
references to store the fetched fields in, \*(L"getline\*(R" will fail with error
\&\f(CW3006\fR. If you pass more than there are fields to return, the content of
the remaining references is left untouched.
.PP
.Vb 4
\& $csv.bind_columns(\e$code, \e$name, \e$price, \e$description);
\& while ($csv.getline($io)) {
\&     print "The price of a $name is \ex[20ac] $price\en";
\&     }
.Ve
.PP
To reset or clear all column binding, call \*(L"bind_columns\*(R" with the single
undefined argument like \f(CW\*(C`Array\*(C'\fR. This will also clear column names.
.PP
.Vb 1
\& $csv.bind_columns(Array);
.Ve
.PP
If no arguments are passed at all, \*(L"bind_columns\*(R" will return the list of
current bindings or \f(CW\*(C`Array\*(C'\fR if no binds are active.
.SS "eof"
.IX Xref "eof"
.IX Subsection "eof"
.Vb 1
\& $eof = $csv.eof;
.Ve
.PP
If \*(L"parse\*(R" or \*(L"getline\*(R" was used with an \s-1IO\s0 stream, this method will
return \f(CW\*(C`True\*(C'\fR if the last call hit end of file, otherwise it will return
\&\f(CW\*(C`False\*(C'\fR. This is useful to see the difference between a failure and end
of file.
.PP
If the last \*(L"parse\*(R" or \*(L"getline\*(R" finished just before end of file, the
\&\fBnext\fR \*(L"parse\*(R" or \*(L"getline\*(R" will fail and set \f(CW\*(C`eof\*(C'\fR.
.PP
That implies that if you are \fInot\fR using \*(L"auto-diag\*(R", an idiom like
.PP
.Vb 4
\& while (my @row = $csv.getline ($fh)) {
\&     # ...
\&     }
\& $csv.eof or $csv.error_diag;
.Ve
.PP
will \fInot\fR report the error. You would have to change that to
.PP
.Vb 4
\& while (my @row = $csv.getline ($fh)) {
\&     # ...
\&     }
\& $csv.error_diag.error and $csv.error_diag;
.Ve
.SS "types"
.IX Xref "types"
.IX Subsection "types"
\&\s-1NYI\s0!
.PP
.Vb 2
\& $csv.types(@types);
\& my @types = $csv.types;
.Ve
.PP
This method is used to force a type for all fields in a column. For
example, if you have an integer column, two columns with doubles and a
string column, then you might do a
.PP
.Vb 1
\& $csv.types(Int, Num, Num, Str);
.Ve
.PP
You can unset column types by doing a
.PP
.Vb 1
\& $csv.types(Array);
.Ve
.SS "row"
.IX Xref "row"
.IX Subsection "row"
.Vb 1
\& CSV::Row $row = $csv.row;
.Ve
.PP
Returns the last row parsed. See \f(CW\*(C`CSV::Row\*(C'\fR
.SS "fields"
.IX Xref "fields"
.IX Subsection "fields"
.Vb 1
\& CSV::Field @fields = $csv.fields;
.Ve
.PP
This method returns the input to \*(L"combine\*(R" or the resultant decomposed
fields of a successful \*(L"parse\*(R" or \*(L"getline\*(R", whichever was called more
recently. The fields are still of type \f(CW\*(C`CSV::Field\*(C'\fR and
thus feature attributes.
.SS "strings"
.IX Xref "strings"
.IX Subsection "strings"
.Vb 1
\& @fields = $csv.strings;
.Ve
.PP
This method returns the input to \*(L"combine\*(R" or the resultant decomposed
fields of a successful \*(L"parse\*(R" or \*(L"getline\*(R", whichever was called more
recently. The fields are simplified to Str entries from
\&\f(CW\*(C`CSV::Field\*(C'\fR, so no attributes ate available.
.PP
\&\s-1NYI:\s0 If types are used, the fields should comply to the types.
.SS "meta_info"
.IX Xref "meta_info"
.IX Subsection "meta_info"
.SS "meta-info"
.IX Xref "meta-info"
.IX Subsection "meta-info"
.Vb 2
\& $csv.meta_info(True);
\& my $km = $csv.keep_meta;
.Ve
.PP
This methods sets or inquires the default setting for keeping meta-info on
fields. See \f(CW\*(C`CSV::Field\*(C'\fR.
.SS "is_quoted"
.IX Xref "is_quoted"
.IX Subsection "is_quoted"
.SS "is-quoted"
.IX Xref "is-quoted"
.IX Subsection "is-quoted"
.Vb 1
\& my $quoted = $csv.is_quoted($column_idx);
.Ve
.PP
Where \f(CW$column_idx\fR is the (zero-based) index of the column in the last
result of \*(L"parse\*(R" or \*(L"getline\*(R", even if \f(CW\*(C`meta\*(C'\fR was false on that last
invocation.
.PP
This returns \f(CW\*(C`True\*(C'\fR if the data in the indicated column was enclosed in
\&\f(CW\*(C`quote_char\*(C'\fR quotes. This might be important for fields
where content \f(CW\*(C`,20070108,\*(C'\fR is to be treated as a numeric value, and where
\&\f(CW\*(C`,"20070108",\*(C'\fR is explicitly marked as character string data.
.PP
Also see \f(CW\*(C`CSV::Field\*(C'\fR.
.SS "is_binary"
.IX Xref "is_binary"
.IX Subsection "is_binary"
.SS "is-binary"
.IX Xref "is-binary"
.IX Subsection "is-binary"
\&\s-1NYI/WIP:\s0 utf8\-c8
.PP
.Vb 1
\& my $binary = $csv.is_binary($column_idx);
.Ve
.PP
Where \f(CW$column_idx\fR is the (zero-based) index of the column in the last
result of \*(L"parse\*(R" or \*(L"getline\*(R", even if \f(CW\*(C`meta\*(C'\fR was false on that last
invocation.
.PP
Also see \f(CW\*(C`CSV::Field\*(C'\fR.
.SS "is_missing"
.IX Xref "is_missing"
.IX Subsection "is_missing"
.SS "is-missing"
.IX Xref "is-missing"
.IX Subsection "is-missing"
\&\s-1NYI\s0
.PP
.Vb 1
\& my $missing = $csv.is_missing($column_idx);
.Ve
.PP
Where \f(CW$column_idx\fR is the (zero-based) index of the column in the last
result of \*(L"parse\*(R" or \*(L"getline\*(R", even if \f(CW\*(C`meta\*(C'\fR was false on that last
invocation.
.PP
.Vb 3
\& while (my @row = $csv.getline_hr($fh, :meta)) {
\&     $csv.is_missing(0) and next; # This was an empty line
\&     }
.Ve
.PP
When using \*(L"getline_hr\*(R", it is impossible to tell if the parsed fields
are undefined because they where not filled in the \f(CW\*(C`CSV\*(C'\fR stream or because
they were not read at all, as \fBall\fR the fields defined by \*(L"column_names\*(R"
are set in the hash-ref. If you still need to know if all fields in each
row are provided, you should enable \f(CW\*(C`keep_meta\*(C'\fR so you can
check the flags.
.SS "status"
.IX Xref "status"
.IX Subsection "status"
.Vb 1
\& $status = $csv.status;
.Ve
.PP
This method returns success (or failure) of the last invoked \*(L"combine\*(R" or
\&\*(L"parse\*(R" call.
.SS "error_input"
.IX Xref "error_input"
.IX Subsection "error_input"
.SS "error-input"
.IX Xref "error-input"
.IX Subsection "error-input"
.Vb 1
\& $bad_argument = $csv.error_input;
.Ve
.PP
This method returns the erroneous argument (if it exists) of \*(L"combine\*(R",
\&\*(L"parse\*(R", or \*(L"getline\*(R", whichever was called most recent. If the last
invocation was successful, \f(CW\*(C`error_input\*(C'\fR will return \f(CW\*(C`Str\*(C'\fR.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Errors are transported internally using the \f(CW\*(C`CSV::Diag\*(C'\fR
class.  Text::CSV will return that object when it fails, so it can be
caught, but on non-fatal failures, like parse returning \f(CW\*(C`False\*(C'\fR, one can
use the methods to inquire the internal status.
.SS "CSV::Diag"
.IX Subsection "CSV::Diag"
The method is created with the widest possible use in mind, serving both
the mindset of raku as well as the direct approach of the old module. It
is immutable: it is created with all available error parameters known at
the time of failure, and the cannot be changed afterwards.
.PP
.Vb 8
\& my CSV::Diag $d .= new(
\&     error   => 0,
\&     message => "",
\&     pos     => 0,
\&     field   => 0,
\&     record  => 0,
\&     buffer  => Str
\&     );
.Ve
.PP
If only \f(CW\*(C`error\*(C'\fR is given, the message is set accordingly if it is a known
error value.
.PP
The object can be used in many contexts:
.IP "void context" 2
.IX Item "void context"
.Vb 1
\& CSV::Diag.new(error => 2034, buffer => q{ "",}, pos => 1);
.Ve
.Sp
will print
.Sp
.Vb 2
\& EIF \- Loose unescaped quote : error 2034 @ record 1, field 1, position 2
\&  "?",
.Ve
.Sp
which is what happens when \f(CW\*(C`auto_diag\*(C'\fR is \f(CW\*(C`True\*(C'\fR and you
parse illegal \s-1CSV:\s0
.Sp
.Vb 3
\& Text::CSV.new(:auto_diag).parse(q{ "",});\*(Aq
\& EIF \- Loose unescaped quote : error 2034 @ record 1, field 1, position 2
\&  "?",
.Ve
.IP "numeric context" 2
.IX Item "numeric context"
Will return the error code
.Sp
.Vb 5
\& my Int $e;
\& {   fail CSV::Diag(error => 2034);
\&     CATCH { default { $e = +$_; }}
\&     }
\& # $e is now 2034
.Ve
.IP "string context" 2
.IX Item "string context"
Will return the error message
.Sp
.Vb 5
\& my Str $e;
\& {   fail CSV::Diag(error => 2034);
\&     CATCH { default { $e = ~$_; }}
\&     }
\& # $e is now "EIF \- Loose unescaped quote"
.Ve
.IP "list context" 2
.IX Item "list context"
All of the 6 items can be retrieved as a list or positional:
.Sp
.Vb 3
\& {   fail CSV::Diag(error => 2034);
\&     CATCH { default { $_[0].say; }}
\&     }
.Ve
.Sp
The indices are chosen to be compatible with the old \s-1API\s0
.Sp
.Vb 6
\& $e[0] = error number
\& $e[1] = error message
\& $e[2] = error position in buffer
\& $e[3] = field number
\& $e[4] = record number
\& $e[5] = errror buffer
.Ve
.IP "hash context" 2
.IX Item "hash context"
All of the 6 items can be retrieved as a hash entry
.Sp
.Vb 3
\& {   fail CSV::Diag(error => 2034);
\&     CATCH { default { $_<errno>.say; }}
\&     }
.Ve
.Sp
The keys are chosen to be compatible with the old \s-1API.\s0
.Sp
.Vb 6
\& $e<errno>  = error number
\& $e<error>  = error message
\& $e<pos>    = error position in buffer
\& $e<field>  = field number
\& $e<recno>  = record number
\& $e<buffer> = errror buffer
.Ve
.PP
The CSV::Diag is also used by this Text::CSV method
.SS "error_diag"
.IX Xref "error_diag"
.IX Subsection "error_diag"
.SS "error-diag"
.IX Xref "error-diag"
.IX Subsection "error-diag"
.Vb 4
\& $csv.error_diag;
\& $error_code = +$csv.error_diag;
\& $error_str  = ~$csv.error_diag;
\& ($cde, $str, $pos, $rec, $fld) = $csv.error_diag;
.Ve
.PP
This function returns the diagnostics of the most recent error.
.PP
If called in void context, this will print the internal error code and the
associated error message along with the record number, the position of the
failure and the buffer of failure with an eject symbol at that position:
.PP
.Vb 2
\& $csv.parse(q{ "",})
\& $csv.error_diag;
.Ve
.PP
will print
.PP
.Vb 2
\& EIF \- Loose unescaped quote : error 2034 @ record 1, field 1, position 2
\&  "?",
.Ve
.PP
If called in list context, this will return the error code, the error
message, the location within the line that was being parsed, the record
number, and the buffer itself in that order. Their values are 1\-based. The
position currently is index of the character at which the parsing failed in
the current record. The record number the index of the record parsed by the
csv instance. The field number is the index of the field the parser thinks
it is currently trying to parse.
.PP
If called as \f(CW\*(C`+$csv.error_diag\*(C'\fR or \f(CW\*(C`$csv.error_diag.Num\*(C'\fR, it will return
the error code. If called as \f(CW\*(C`~$csv.error_diag\*(C'\fR or \f(CW\*(C`$csv.error_diag.Str\*(C'\fR
it will return the error message.
.SS "record_number"
.IX Xref "record_number"
.IX Subsection "record_number"
.Vb 1
\& $recno = $csv.record_number;
.Ve
.PP
Returns the records parsed by this csv instance. This value should be more
accurate than \f(CW$.\fR when embedded newlines come in play. Records written by
this instance are not counted.
.SS "set_diag"
.IX Xref "set_diag"
.IX Subsection "set_diag"
.Vb 2
\& $csv.set_diag(0);
\& $csv.set_diag(2025, pos => 12, fieldno => 4, recno => 99);
.Ve
.PP
Use to (re)set the diagnostics if you are dealing with errors.
.SH "CSV::Field"
.IX Header "CSV::Field"
The fields are internally represented as CSV::Field objects. Any methods
that directly or indirectly supports the \f(CW\*(C`meta\*(C'\fR attribute controls
weather the returned fields will be of this CSV::Field type or that the
fields are simplified to a simple basic type.
.PP
If the fields are represented/returned as CSV::Field, it supports these
methods:
.SS "new"
.IX Subsection "new"
.Vb 3
\& my CSV::Field $f .= new;
\& my $f = CSV::Field.new("foo");
\& my $f = CSV::Field.new(1);
.Ve
.PP
Instantiate a new field. Optionally takes a \f(CW\*(C`Cool\*(C'\fR.
.SS "Bool"
.IX Subsection "Bool"
.Vb 2
\& ?$f     and say "The field is true";
\& $f.Bool and say "This field is true too";
.Ve
.PP
Return the boolean value of the field. As \s-1CSV\s0 is text-only be design, this
will also return \f(CW\*(C`False\*(C'\fR for \f(CW"0"\fR, where raku sees \f(CW"0"\fR as \f(CW\*(C`True\*(C'\fR.
.SS "text =head2 Str"
.IX Subsection "text =head2 Str"
.Vb 3
\& $str = ~$f;
\& $str = $f.Str;
\& $str = $f.text;
.Ve
.PP
Return the string representation of the field.
.SS "Buf"
.IX Subsection "Buf"
.Vb 1
\& $buf = $f.Buf;
.Ve
.PP
Return the field data as \*(L"utf8\-c8\*(R" encoded Buf.
.SS "Numeric"
.IX Subsection "Numeric"
.Vb 3
\& $i = +$f;
\& $i = $f.Int;
\& $i = $f.Num;
.Ve
.PP
Return the numeric representation of the field.
.SS "gist"
.IX Subsection "gist"
.Vb 1
\& $f.gist.say;
.Ve
.PP
Will show a complete compressed representation of the field with properties.
\&\f(CW\*(C`Q\*(C'\fR is quoted, \f(CW\*(C`q\*(C'\fR is unquoted. Likewise for \f(CW\*(C`B/b\*(C'\fR for binary, \f(CW\*(C`8/7\*(C'\fR
for Unicode-ness and \f(CW\*(C`M/m\*(C'\fR for missing.
.PP
A field that was parsed as \f(CW\*(C`,cat,\*(C'\fR would return
.PP
.Vb 1
\& qb7m:"cat"
.Ve
.PP
A field parsed as \f(CW\*(C`,"XXXXX",\*(C'\fR would return
.PP
.Vb 1
\& QB8m:"XXXXX"
.Ve
.SS "add"
.IX Subsection "add"
.Vb 1
\& $f.add($str);
.Ve
.PP
Accepts a Str to be added to this field.
.SS "set_quoted"
.IX Subsection "set_quoted"
.Vb 1
\& $f.set_quoted;
.Ve
.PP
Set the fact the the field was/is quoted.
.SS "is_quoted"
.IX Subsection "is_quoted"
.Vb 1
\& $f.is_quoted and say "The field was quoted in CSV";
.Ve
.PP
Is \f(CW\*(C`True\*(C'\fR when the parsed field was quoted in the source.
.SS "undefined"
.IX Subsection "undefined"
.Vb 1
\& $f.undefined and say "The field is undefined";
.Ve
.PP
Returns \f(CW\*(C`True\*(C'\fR when the field is undefined. As \s-1CSV\s0 is all about strings,
the various options that allow interpreting empty fields as undefined make
this a required method.
.SS "is_binary"
.IX Subsection "is_binary"
\&\s-1WIP:\s0 utf8\-c8
.PP
.Vb 1
\& $f.is_binary and say "Do we need a Buf instead?";
.Ve
.PP
Returns true if the field has data beyond \s-1ASCII.\s0
.SS "is_utf8"
.IX Subsection "is_utf8"
.Vb 1
\& $f.is_utf8 or say "The field is empty or pure ACII";
.Ve
.PP
Returns \f(CW\*(C`True\*(C'\fR if the field is beyond \s-1ASCII,\s0 but still valid \s-1UTF\-8.\s0
.SS "is_missing"
.IX Subsection "is_missing"
\&\s-1WIP\s0
.PP
.Vb 1
\& $f.is_missing and fail;
.Ve
.PP
Returns \f(CW\*(C`True\*(C'\fR if the field is missing.
.SH "CSV::Row"
.IX Xref "CSV::Row"
.IX Header "CSV::Row"
This class is a wrapper over the current row of fields just to add
convenience methods.
.PP
This is the only argument to callbacks.
.PP
The fields in \f(CW\*(C`CSV::Row\*(C'\fR are always of class \f(CW\*(C`CSV::Field\*(C'\fR
and thus contain all meta-information, even if the \f(CW\*(C`Text::CSV\*(C'\fR attribute
\&\f(CW\*(C`meta_info\*(C'\fR is \f(CW\*(C`False\*(C'\fR.
.SS "methods"
.IX Subsection "methods"
.IP "new" 2
.IX Item "new"
.Vb 2
\& my CSV::Row $row .= new;
\& my CSV::Row $row .= new(csv => $csv, fields => @f.map({ CSV::Field.new(*) });
.Ve
.IP "csv" 2
.IX Item "csv"
The current Text::CSV object related to this row.
.IP "elems" 2
.IX Item "elems"
Return the number of fields in the row.
.IP "fields" 2
.IX Item "fields"
The fields (CSV::Field items) this row consist of.
.IP "push" 2
.IX Item "push"
.Vb 4
\& $row.push(CSV::Field.new(1));
\& $row.push(1);
\& $row.push("foo");
\& $row.push($another\-row);
.Ve
.Sp
Pushing simple things onto the row will extend the row by converting these
to CSV::Field objects.
.Sp
Pushing a CSV::Row onto the row will extend that row with the fields of the
row being pushed.
.IP "pop" 2
.IX Item "pop"
.Vb 1
\& my CSV::Field $f = $row.pop;
.Ve
.IP "Str" 2
.IX Item "Str"
.Vb 2
\& my $str = $row.Str;
\& $io.say(~$row);
.Ve
.Sp
The stringification of the CSV::Row object is like invoking the
\&\f(CW\*(C`string\*(C'\fR method. This only works if there is a Text::CSV
object known to the CSV::Row instance.
.IP "hash" 2
.IX Item "hash"
.Vb 1
\& my %h = $row.hash;
.Ve
.Sp
Returns the hash with \f(CW\*(C`.csv\*(C'\fR's \f(CW\*(C`column_names\*(C'\fR as keys
and the \f(CW\*(C`.text\*(C'\fR of each matching \f(CW\*(C`fields\*(C'\fR entry as values.
.IP "strings" 2
.IX Item "strings"
.Vb 1
\& my @l = $row.strings;
.Ve
.Sp
Returns the \f(CW\*(C`.text\*(C'\fR part of each entry in \f(CW\*(C`.fields\*(C'\fR.
.PP
The row allow direct indexing and iteration as well as hash addressing when
\&\*(L"column_names\*(R" are set.
.PP
.Vb 2
\& my $field = $row[1];
\& my $field = $row<foo>;
.Ve
.PP
The last parsed row of a Text::CSV|/Text::CSV> can be acquired using
.PP
.Vb 1
\& my CSV::Row $row = $csv.row;
.Ve
.PP
################################################################################
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "csv"
.IX Xref "csv"
.IX Subsection "csv"
This is an high-level function that aims at simple (user) interfaces. This
can be used to read/parse a \f(CW\*(C`CSV\*(C'\fR file or stream (the default behavior) or
to produce a file or write to a stream (define the \f(CW\*(C`out\*(C'\fR attribute). It
returns an array\- or hash-reference on parsing or the
numeric value of \*(L"error_diag\*(R" on writing. When this function fails you
can get to the error using the class call to \*(L"error_diag\*(R"
.PP
.Vb 2
\& my $aoa = csv(in => "test.csv") or
\&     die Text::CSV.error_diag;
.Ve
.PP
This function takes the arguments as key-value pairs. This can be passed as
a list or as an anonymous hash:
.PP
.Vb 2
\& my $aoa = csv(in => "test.csv", sep => ";");
\& my $aoh = csv(in => $fh, :headers);
.Ve
.PP
The arguments passed consist of two parts: the arguments to \*(L"csv\*(R" itself
and the optional attributes to the \f(CW\*(C`CSV\*(C'\fR object used inside the function
as enumerated and explained in \*(L"new\*(R".
.PP
If not overridden, the default option used for \s-1CSV\s0 is
.PP
.Vb 1
\& auto_diag => 1
.Ve
.PP
The option that is always set and cannot be altered is
.PP
.Vb 1
\& binary    => 1
.Ve
.PP
\fIin\fR
.IX Xref "in"
.IX Subsection "in"
.PP
Used to specify the source. \f(CW\*(C`in\*(C'\fR can be a file name (e.g. \f(CW"file.csv"\fR),
which will be opened for reading and closed when finished, a file handle
(e.g. \f(CW$fh\fR or \f(CW\*(C`FH\*(C'\fR), a reference to a glob (e.g. \f(CW\*(C`\e*ARGV\*(C'\fR), the glob
itself (e.g. \f(CW*STDIN\fR), or a reference to a scalar (e.g. \f(CW\*(C`\eq{1,2,"csv"}\*(C'\fR).
.PP
When used with \*(L"out\*(R", \f(CW\*(C`in\*(C'\fR should be a reference to a \s-1CSV\s0 structure (AoA
or AoH) or a Callable (Sub, Routine, Code, or Block) that returns an
array-reference or a hash-reference.  The code-ref will be invoked with no
arguments.
.PP
.Vb 1
\& my $aoa = csv(in => "file.csv");
\&
\& open my $fh, "<", "file.csv";
\& my $aoa = csv(in => $fh);
\&
\& my $csv = [[qw( Foo Bar )], [ 1, 2 ], [ 2, 3 ]];
\& my $err = csv(in => $csv, out => "file.csv");
.Ve
.PP
The \f(CW\*(C`in\*(C'\fR attribute supports a wide range of types, all of which can be
combined with the use of \f(CW\*(C`fragment\*(C'\fR:
.IP "Str" 2
.IX Item "Str"
.Vb 1
\& csv(in => "file.csv")
.Ve
.Sp
A plain string is interpreted as a file name to be opened for parsing.
.IP "\s-1IO\s0" 2
.IX Item "IO"
.Vb 2
\& my $io = open "file.csv", :r;
\& csv(in => $io);
.Ve
.Sp
Parse from the already opened data stream.
.IP "Capture" 2
.IX Item "Capture"
.Vb 1
\& csv(in => \e("str,ing"));
.Ve
.Sp
Parse from a single string.
.IP "Array of Strings" 2
.IX Item "Array of Strings"
.Vb 2
\& csv(in => ["a,b\en1,2\en3,4\en"]);
\& csv(in => ["a,b", "1,2", "3,4"]);
.Ve
.Sp
Parse from the String(s)
.IP "Array of Data" 2
.IX Item "Array of Data"
.Vb 2
\& csv(in => [[<a b>], [1, 2], [3, 4]]);
\& csv(in => [{:a(1), :b(2)}, {:a(3), :b(4)}]);
.Ve
.Sp
Use the data as provided
.IP "Sub, Routine" 2
.IX Item "Sub, Routine"
.Vb 5
\& sub provider {
\&     @data.elems == 0 and return False;
\&     return @data.pop;
\&     }
\& csv(in => &provider);
.Ve
.Sp
While the providing Routine returns a data row, use that as is. Stop when
the provider returns \f(CW\*(C`False\*(C'\fR.
.IP "Callable, Block" 2
.IX Item "Callable, Block"
.Vb 1
\& csv(in => { $sth.fetch });
.Ve
.Sp
While the providing Callable returns a data row, use that as is. Stop when
the provider returns \f(CW\*(C`False\*(C'\fR.
.IP "Supply" 2
.IX Item "Supply"
.Vb 2
\& my $supply = Supply.from\-list(@data);
\& csv(in => $supply);
.Ve
.Sp
Fetch data rows from the supply.
.IP "Channel" 2
.IX Item "Channel"
.Vb 6
\& my $ch = Channel.new;
\& start {
\&     $ch.send($_) for @data;
\&     $ch.close;
\&     }
\& csv(in => $ch);
.Ve
.Sp
Fetch data from the Channel.
.IP "Iterator" 2
.IX Item "Iterator"
.Vb 1
\& csv(in => @data.iterator);
.Ve
.Sp
Fetch data rows from the iterator.
.IP "Any" 2
.IX Item "Any"
.Vb 1
\& csv(in => Any);
.Ve
.Sp
is a shortcut/fallback for
.Sp
.Vb 1
\& csv(in => $*IN);
.Ve
.PP
\fIout\fR
.IX Xref "out"
.IX Subsection "out"
.PP
In output mode, the default \s-1CSV\s0 options when producing \s-1CSV\s0 are
.PP
.Vb 1
\& eol    => "\er\en"
.Ve
.PP
The \*(L"fragment\*(R" attribute is ignored in output mode.
.PP
\&\f(CW\*(C`out\*(C'\fR can be a file name (e.g. \f(CW"file.csv"\fR), which will be opened for
writing and closed when finished, a file handle (e.g. \f(CW$fh\fR or
\&\f(CW\*(C`IO::Handle\*(C'\fR), a \f(CW\*(C`Channel\*(C'\fR, a \f(CW\*(C`Supply\*(C'\fR, a \f(CW\*(C`Callable\*(C'\fR, or \f(CW\*(C`Nil\*(C'\fR.
.PP
.Vb 3
\& csv(in => sub { $sth.fetch },        out => "dump.csv");
\& csv(in => { $sth.fetchrow_hashref }, out => "dump.csv",
\&      headers => $sth.{NAME_lc});
.Ve
.PP
When a code-ref is used for \f(CW\*(C`in\*(C'\fR, the output is generated per invocation,
so no buffering is involved. This implies that there is no size restriction
on the number of records. The \f(CW\*(C`csv\*(C'\fR function ends when the coderef returns
\&\f(CW\*(C`False\*(C'\fR.
.PP
When a Callable is used for out, it is called on each row with the row as
only argument.
.PP
When \f(CW\*(C`Nil\*(C'\fR is used for out, the output is completely suppressed. This can
be useful when streaming, and the output is not required, but the
side-effects of e.g. an \f(CW\*(C`on\-in\*(C'\fR hook is dealing with the data.
.IP "Str:U" 2
.IX Item "Str:U"
.Vb 1
\& my $str = csv(in => $in, out => Str);
.Ve
.Sp
Returns a single String of \s-1CSV\s0 data.
.IP "Str:D" 2
.IX Item "Str:D"
.Vb 1
\& my $str = csv(in => $in, out => "out.csv");
.Ve
.Sp
Writes the data as \s-1CSV\s0 to the named file.
.IP "Array:U" 2
.IX Item "Array:U"
.Vb 1
\& my $aoa = csv(in => $in, out => Array);
.Ve
.Sp
Returns an Array of Arrays.
.IP "Array:D" 2
.IX Item "Array:D"
.Vb 1
\& my $aoa = csv(in => $in, out => @data);
.Ve
.Sp
Adds the records to an existing Array. If the existing array is not empty,
the type of the first record determines adding a list of Arrays or a list
of Hashes.
.IP "Hash:U" 2
.IX Item "Hash:U"
.Vb 1
\& my $aoh = csv(in => $in, out => Hash);
.Ve
.Sp
Returns an Array of Hashes
.IP "\s-1IO:D\s0" 2
.IX Item "IO:D"
.Vb 2
\& my $io = open "file.csv", :w;
\& csv(in => $in, out => $io);
.Ve
.Sp
Writes the data as \s-1CSV\s0 to the \s-1IO\s0 handle.
.IP "Callable, Block, Sub, Routine" 2
.IX Item "Callable, Block, Sub, Routine"
.Vb 2
\& my @d;
\& csv(in => $in, out => { @d.push: $_ });
.Ve
.Sp
Passes the data rows to the Callable
.IP "Channel:U" 2
.IX Item "Channel:U"
.Vb 7
\& my $ch = csv(in => $in, out => Channel, :!meta);
\& react {
\&     whenever $ch \-> \erow {
\&         @d.push: row;
\&         LAST { done; }
\&         }
\&     }
.Ve
.Sp
Writes the data rows into a new Channel, which is returned.
.IP "Channel:D" 2
.IX Item "Channel:D"
.Vb 11
\& my $ch = Channel.new;
\& my $pr = start {
\&     react {
\&         whenever $ch \-> \erow {
\&             @d.push: row;
\&             LAST { done; }
\&             }
\&         }
\&     }
\& csv(in => $in, out => $ch);
\& await $pr;
.Ve
.Sp
Writes the data rows into the existing Channel.
.IP "Supplier:D" 2
.IX Item "Supplier:D"
.Vb 3
\& my $sup = Supplier.new;
\& $sup.Supply.tap (\-> \erow { @d.push: row; });
\& csv(in => $in, out => $sup, :!meta);
.Ve
.Sp
Writes the data rows into the Supplier.
.IP "Supply:U" 2
.IX Item "Supply:U"
.Vb 2
\& my $sup = csv(in => $in, out => Supply, :!meta);
\& $ch.tap (\-> \erow { @d.push: row; });
.Ve
.Sp
Writes the data rows into a new Supply.
.PP
\fIencoding\fR
.IX Xref "encoding"
.IX Subsection "encoding"
.PP
If passed, it should be an encoding accepted by the \f(CW\*(C`:encoding()\*(C'\fR option
to \f(CW\*(C`open\*(C'\fR. There is no default value.
.PP
If \f(CW\*(C`encoding\*(C'\fR is set to the literal value \f(CW"auto"\fR, the method \*(L"header\*(R"
will be invoked on the opened stream to check if there is a \s-1BOM\s0 and set the
encoding accordingly. This is equal to passing True in the option
\&\f(CW\*(C`detect\-bom\*(C'\fR.
.PP
\fIdetect-bom\fR
.IX Xref "detect-bom detect_bom"
.IX Subsection "detect-bom"
.PP
\&\s-1NYI\s0 for various reasons. Also see \*(L"is-binary\*(R"
.PP
If \f(CW\*(C`detect\-bom\*(C'\fR is given, the method \*(L"header\*(R" will be invoked on the
opened stream to check if there is a \s-1BOM\s0 and set the encoding accordingly.
.PP
\&\f(CW\*(C`detect_bom\*(C'\fR can be abbreviated to \f(CW\*(C`bom\*(C'\fR.
.PP
This is the same as setting \f(CW\*(C`encoding\*(C'\fR to \f(CW"auto"\fR.
.PP
Note that as the method \*(L"header\*(R" is invoked, its default is to also set
the headers.
.PP
\fIheaders\fR
.IX Xref "headers"
.IX Subsection "headers"
.PP
If this attribute is not given, the default behavior is to produce an array
of arrays.
.PP
If \f(CW\*(C`headers\*(C'\fR is supplied, it should be an Array of column names, a Bool, a
Hash, a Callable, or a literal flag: \f(CW\*(C`auto\*(C'\fR, \f(CW\*(C`lc\*(C'\fR, \f(CW\*(C`uc\*(C'\fR, or \f(CW\*(C`skip\*(C'\fR.
.IP "skip" 2
.IX Item "skip"
When \f(CW\*(C`skip\*(C'\fR is used, the header will not be included in the output.
.Sp
.Vb 1
\& my $aoa = csv(in => $fh, headers => "skip");
.Ve
.IP "auto" 2
.IX Item "auto"
If \f(CW\*(C`auto\*(C'\fR is used, the first line of the \f(CW\*(C`CSV\*(C'\fR source will be read as the
list of field headers and used to produce an array of hashes.
.Sp
.Vb 1
\& my $aoh = csv(in => $fh, headers => "auto");
.Ve
.IP "lc" 2
.IX Item "lc"
If \f(CW\*(C`lc\*(C'\fR is used, the first line of the \f(CW\*(C`CSV\*(C'\fR source will be read as the
list of field headers mapped to lower case and used to produce an array of
hashes. This is a variation of \f(CW\*(C`auto\*(C'\fR.
.Sp
.Vb 1
\& my $aoh = csv(in => $fh, headers => "lc");
.Ve
.IP "uc" 2
.IX Item "uc"
If \f(CW\*(C`uc\*(C'\fR is used, the first line of the \f(CW\*(C`CSV\*(C'\fR source will be read as the
list of field headers mapped to upper case and used to produce an array of
hashes. This is a variation of \f(CW\*(C`auto\*(C'\fR.
.Sp
.Vb 1
\& my $aoh = csv(in => $fh, headers => "uc");
.Ve
.IP "Bool" 2
.IX Item "Bool"
If \f(CW\*(C`True\*(C'\fR is passed, the method \*(L"header\*(R" will be invoked with the
default options on the opened stream to check if there is a \s-1BOM\s0 and set the
encoding accordingly, detect and set \f(CW\*(C`sep\*(C'\fR, \f(CW\*(C`eol\*(C'\fR and
column names.
.IP "Callable" 2
.IX Item "Callable"
If a Callable is used, the first line of the \f(CW\*(C`CSV\*(C'\fR source will be read as
the list of mangled field headers in which each field is passed as the only
argument to the coderef. This list is used to produce an array of hashes.
.Sp
.Vb 2
\& my $i = 0;
\& my $aoh = csv(in => $fh, headers => { $^h.lc ~ $i++ });
.Ve
.Sp
this example is a variation of using \f(CW\*(C`lc\*(C'\fR where all headers are forced to
be unique by adding an index.
.IP "\s-1ARRAY\s0" 2
.IX Item "ARRAY"
If  \f(CW\*(C`headers\*(C'\fR is an Array, the entries in the list will be used as field
names. The first line is considered data instead of headers.
.Sp
.Vb 1
\& my $aoh = csv(in => $fh, headers => [< Foo Bar >]);
.Ve
.IP "\s-1HASH\s0" 2
.IX Item "HASH"
If \f(CW\*(C`headers\*(C'\fR is a Hash, this implies \f(CW\*(C`auto\*(C'\fR, but header fields for that
exist as key in the Hash will be replaced by the value for that key. Given
a \s-1CSV\s0 file like
.Sp
.Vb 2
\& post\-kode,city,name,id number,fubble
\& 1234AA,Duckstad,Donald,13,"X313DF"
.Ve
.Sp
using
.Sp
.Vb 1
\& csv (headers => %{ "post\-kode" => "pc", "id number" => "ID" }, ...
.Ve
.Sp
will return an entry like
.Sp
.Vb 6
\& { pc     => "1234AA",
\&   city   => "Duckstad",
\&   name   => "Donald",
\&   ID     => "13",
\&   fubble => "X313DF",
\&   }
.Ve
.PP
See also \f(CW\*(C`munge\-column\-names\*(C'\fR and
\&\f(CW\*(C`set\-column\-names\*(C'\fR.
.PP
\fImunge-column-names\fR
.IX Xref "munge-column-names munge_column_names"
.IX Subsection "munge-column-names"
.PP
If \f(CW\*(C`munge\-column\-names\*(C'\fR is set, the method \*(L"header\*(R" is invoked on the
opened stream with all matching arguments to detect and set the headers.
.PP
\&\f(CW\*(C`munge\-column\-names\*(C'\fR can be abbreviated to \f(CW\*(C`munge\*(C'\fR.
.PP
\fIkey\fR
.IX Xref "key"
.IX Subsection "key"
.PP
If passed, will default \f(CW\*(C`headers\*(C'\fR to \f(CW"auto"\fR and return a
hashref instead of an array of hashes. Allowed values are simple strings
or arrays where the first element is the joiner and the rest are the fields
to join to combine the key
.PP
.Vb 2
\& my $ref = csv(in => "test.csv", key =>        "code");
\& my $ref = csv(in => "test.csv", key => [ ":", "code", "color" ]);
.Ve
.PP
with test.csv like
.PP
.Vb 4
\& code,product,price,color
\& 1,pc,850,gray
\& 2,keyboard,12,white
\& 3,mouse,5,black
.Ve
.PP
the first example will return
.PP
.Vb 10
\& { 1   => {
\&       code    => 1,
\&       color   => \*(Aqgray\*(Aq,
\&       price   => 850,
\&       product => \*(Aqpc\*(Aq
\&       },
\&   2   => {
\&       code    => 2,
\&       color   => \*(Aqwhite\*(Aq,
\&       price   => 12,
\&       product => \*(Aqkeyboard\*(Aq
\&       },
\&   3   => {
\&       code    => 3,
\&       color   => \*(Aqblack\*(Aq,
\&       price   => 5,
\&       product => \*(Aqmouse\*(Aq
\&       }
\&   }
.Ve
.PP
the second example will return
.PP
.Vb 10
\& { "1:gray"    => {
\&       code    => 1,
\&       color   => \*(Aqgray\*(Aq,
\&       price   => 850,
\&       product => \*(Aqpc\*(Aq
\&       },
\&   "2:white"   => {
\&       code    => 2,
\&       color   => \*(Aqwhite\*(Aq,
\&       price   => 12,
\&       product => \*(Aqkeyboard\*(Aq
\&       },
\&   "3:black"   => {
\&       code    => 3,
\&       color   => \*(Aqblack\*(Aq,
\&       price   => 5,
\&       product => \*(Aqmouse\*(Aq
\&       }
\&   }
.Ve
.PP
If \f(CW\*(C`out\*(C'\fR points to an existing Hash, the data will be added to that instead
(existing records will be overwritten on reading duplicate keys). It returns
the value passed to \f(CW\*(C`out\*(C'\fR:
.PP
.Vb 2
\& my $ref = csv(in => "test.csv", out => %hash, key =>        "code");
\& my $ref = csv(in => "test.csv", out => %hash, key => [ ":", "code", "color" ]);
.Ve
.PP
\fIfragment\fR
.IX Xref "fragment"
.IX Subsection "fragment"
.PP
Only output the fragment as defined in the \*(L"fragment\*(R" method. This option
is ignored when \fIgenerating\fR \f(CW\*(C`CSV\*(C'\fR. See \*(L"out\*(R".
.PP
Combining all of them could give something like
.PP
.Vb 9
\& use Text::CSV qw( csv );
\& my @aoh = csv(
\&     in       => "test.txt",
\&     encoding => "utf\-8",
\&     headers  => "auto",
\&     sep_char => "|",
\&     fragment => "row=3;6\-9;15\-*",
\&     );
\& say @aoh[15]{Foo};
.Ve
.PP
\fIsep-set\fR
.IX Xref "sep-set sep_set seps"
.IX Subsection "sep-set"
.PP
If \f(CW\*(C`sep\-set\*(C'\fR is set, the method \*(L"header\*(R" is invoked on the opened stream
to detect and set \f(CW\*(C`sep\*(C'\fR with the given set.
.PP
\&\f(CW\*(C`sep\-set\*(C'\fR can be abbreviated to \f(CW\*(C`seps\*(C'\fR.
.PP
Note that as the method \*(L"header\*(R" is invoked, its default is to also set
the headers.
.PP
\fIset_column_names\fR
.IX Xref "set_column_names"
.IX Subsection "set_column_names"
.PP
If  \f(CW\*(C`set_column_names\*(C'\fR is passed,  the method \*(L"header\*(R" is invoked on the
opened stream with all arguments meant for \*(L"header\*(R".
.SS "Callbacks"
.IX Subsection "Callbacks"
Callbacks enable actions triggered from the \fIinside\fR of Text::CSV.
.PP
While most of what this enables can easily be done in an unrolled loop as
described in the \*(L"\s-1SYNOPSIS\*(R"\s0 callbacks, can be used to meet special
demands or enhance the \*(L"csv\*(R" function.
.PP
All callbacks except \f(CW\*(C`error\*(C'\fR are called with just one argument: the
current CSV::Row.
.IP "error" 2
.IX Xref "error"
.IX Item "error"
.Vb 1
\& $csv.callbacks(error => { $csv.SetDiag(0) });
.Ve
.Sp
the \f(CW\*(C`error\*(C'\fR callback is invoked when an error occurs, but \fIonly\fR when
\&\*(L"auto_diag\*(R" is set to a true value. This callback is invoked with the
values returned by \*(L"error_diag\*(R":
.Sp
.Vb 1
\& my ($c, $s);
\&
\& sub ignore3006 (Int $err, Str $msg, Int $pos, Int $recno, Int $fldno) {
\&     if ($err == 3006) {
\&         # ignore this error
\&         ($c, $s) = (Str, Str);
\&         Text::CSV.SetDiag(0);
\&         }
\&     # Any other error
\&     return;
\&     } # ignore3006
\&
\& $csv.callbacks(error => \e&ignore3006);
\& $csv.bind_columns(\e$c, \e$s);
\& while ($csv.getline($fh)) {
\&     # Error 3006 will not stop the loop
\&     }
.Ve
.IP "after_parse" 2
.IX Xref "after_parse after-parse"
.IX Item "after_parse"
.Vb 5
\& sub add\-new (CSV::Row $r) { $r.fields.push: "NEW"; }
\& $csv.callbacks(after_parse => &add\-new);
\& while (my @row = $csv.getline($fh)) {
\&     @row[\-1] eq "NEW";
\&     }
.Ve
.Sp
This callback is invoked after parsing with \*(L"getline\*(R" only if no error
occurred.
.Sp
The return code of the callback is ignored.
.Sp
.Vb 4
\& sub add_from_db (CSV::Row $r) {
\&     $sth.execute($r[4]);
\&     push $r.fields: $sth.fetchrow_array;
\&     } # add_from_db
\&
\& my $aoa = csv(in => "file.csv", callbacks => {
\&     after_parse => &add_from_db });
\&
\& my $aoa = csv(in => "file.csv", after_parse => {
\&     $sth.execute($^row[4]); $^row.fields.push: $sth.fetchrow_array; });
.Ve
.IP "before_print" 2
.IX Xref "before_print before-print"
.IX Item "before_print"
.Vb 3
\& my $idx = 1;
\& $csv.callbacks(before_print => { $^row[0] = $idx++ });
\& $csv.print(*STDOUT, [ 0, $_ ]) for @members;
.Ve
.Sp
This callback is invoked before printing with \*(L"print\*(R" only if no error
occurred.
.Sp
The return code of the callback is ignored.
.Sp
.Vb 3
\& sub max_4_fields (CSV::Row $r) {
\&     $r.elems > 4 and $r.splice (4);
\&     } # max_4_fields
\&
\& csv(in => csv(in => "file.csv"), out => *STDOUT,
\&     callbacks => { before print => \e&max_4_fields });
\&
\& csv(in => csv(in => "file.csv"), out => *STDOUT,
\&     before print => { $^row.elems > 4 and $^row.splice(4) });
.Ve
.Sp
This callback is not active for \*(L"combine\*(R".
.PP
\fICallbacks for csv\fR
.IX Subsection "Callbacks for csv"
.PP
The \*(L"csv\*(R" allows for some callbacks that do not integrate in internals
but only feature the \*(L"csv\*(R" function. \s-1XXX:\s0 Is this still true?
.PP
.Vb 7
\& csv(in        => "file.csv",
\&     callbacks => {
\&         after_parse  => { say "AFTER PARSE";  }, # first
\&         after_in     => { say "AFTER IN";     }, # second
\&         on_in        => { say "ON IN";        }, # third
\&         },
\&     );
\&
\& csv(in        => $aoh,
\&     out       => "file.csv",
\&     callbacks => {
\&         on_in        => { say "ON IN";        }, # first
\&         before_out   => { say "BEFORE OUT";   }, # second
\&         before_print => { say "BEFORE PRINT"; }, # third
\&         },
\&     );
.Ve
.IP "filter" 2
.IX Xref "filter"
.IX Item "filter"
This callback can be used to filter records. It is called just after a new
record has been scanned. The callback will be invoked with the current
\&\*(L"CSV::Row\*(R" and should return \f(CW\*(C`True\*(C'\fR for records to accept and \f(CW\*(C`False\*(C'\fR
for records to reject.
.Sp
.Vb 4
\& csv (in => "file.csv", filter => {
\&            $^row[2] ~~ /a/ &&  # third field should contain an "a"
\&            $^row[4].chars > 4  # length of the 5th field minimal 5
\&            });
\&
\& csv (in => "file.csv", filter => "not_blank");
\& csv (in => "file.csv", filter => "not_empty");
\& csv (in => "file.csv", filter => "filled");
.Ve
.Sp
If the filter is used to \fIalter\fR the content of a field, make sure that
the sub, block or callable returns true in order not to have that record
skipped:
.Sp
.Vb 1
\& filter => { $^row[1].text .= uc }
.Ve
.Sp
will upper-case the second field, and then skip it if the resulting content
evaluates to false. To always accept, end with truth:
.Sp
.Vb 1
\& filter => { $^row[1].text .= uc; 1 }}
.Ve
.Sp
\&\fBPredefined filters\fR
.Sp
Given a file like (line numbers prefixed for doc purpose only):
.Sp
.Vb 9
\& 1:1,2,3
\& 2:
\& 3:,
\& 4:""
\& 5:,,
\& 6:, ,
\& 7:"",
\& 8:" "
\& 9:4,5,6
.Ve
.RS 2
.IP "not_blank =item not-blank" 2
.IX Item "not_blank =item not-blank"
Filter out the blank lines
.Sp
This filter is a shortcut for
.Sp
.Vb 3
\& filter => { $^row.elems > 1 or
\&             $^row[0].defined && $^row[0] ne "" or
\&             $^row[0].is\-quoted }
.Ve
.Sp
With the given example, line 2 will be skipped.
.IP "not_empty =item not-empty" 2
.IX Item "not_empty =item not-empty"
Filter out lines where all the fields are empty.
.Sp
This filter is a shortcut for
.Sp
.Vb 1
\& filter => { $^row.first: { .defined && $_ ne ""   }}
.Ve
.Sp
A space is not regarded being empty, so given the example data, lines 2, 3,
4, 5, and 7 are skipped.
.IP "filled" 2
.IX Item "filled"
Filter out lines that have no visible data
.Sp
This filter is a shortcut for
.Sp
.Vb 1
\& filter => { $^row.first: { .defined && $_ ~~ /\eS/ }}
.Ve
.Sp
This filter rejects all lines that \fInot\fR have at least one field that does
not evaluate to the empty string.
.Sp
With the given example data, this filter would skip lines 2 through 8.
.RE
.RS 2
.RE
.IP "after_in" 2
.IX Xref "after_in after-in"
.IX Item "after_in"
This callback is invoked for each record after all records have been parsed
but before returning the reference to the caller.
.Sp
This callback can also be passed as an attribute to \*(L"csv\*(R" without the
\&\f(CW\*(C`callbacks\*(C'\fR wrapper.
.IP "before_out" 2
.IX Xref "before_out before-out"
.IX Item "before_out"
This callback is invoked for each record before the record is printed.
.Sp
This callback can also be passed as an attribute to \*(L"csv\*(R" without the
\&\f(CW\*(C`callbacks\*(C'\fR wrapper.
.IP "on_in" 2
.IX Xref "on_in on-in"
.IX Item "on_in"
This callback acts exactly as the \*(L"after_in\*(R" or the \*(L"before_out\*(R" hooks.
.Sp
This callback can also be passed as an attribute to \*(L"csv\*(R" without the
\&\f(CW\*(C`callbacks\*(C'\fR wrapper.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Reading a \s-1CSV\s0 file line by line:"
.IX Subsection "Reading a CSV file line by line:"
.Vb 6
\& my $csv = Text::CSV.new(:auto_diag);
\& my $fh = open "file.csv", :r, :!chomp;
\& while (my @row = $csv.getline($fh)) {
\&     # do something with @$row
\&     }
\& $fh.close;
.Ve
.PP
\fIReading only a single column\fR
.IX Subsection "Reading only a single column"
.PP
.Vb 5
\& my $csv = Text::CSV.new(:auto_diag);
\& my $fh = open "file.csv", :r, :!chomp;
\& # get only the 4th column
\& my @column = $csv.getline_all($fh).map(*[3]);
\& $fh.close;
.Ve
.PP
with \*(L"csv\*(R", you could do
.PP
.Vb 1
\& my @column = csv(in => "file.csv", fragment => "col=4").map(*[0]);
.Ve
.PP
or
.PP
.Vb 1
\& my @column = csv(in => "file.csv", fragment => "col=4").map(*.flat);
.Ve
.SS "Parsing \s-1CSV\s0 strings:"
.IX Subsection "Parsing CSV strings:"
.Vb 1
\& my $csv = Text::CSV.new(:keep_meta);
\&
\& my $sample_input_string =
\&     q{"I said, ""Hi!""",Yes,"",2.34,,"1.09","\ex[20ac]",};
\& if ($csv.parse($sample_input_string)) {
\&     my @field = $csv.fields;
\&     for ^@field.elems \-> $col {
\&         my $quo = $csv.is_quoted($col) ? $csv.{quote_char} : "";
\&         printf "%2d: %s%s%s\en", $col, $quo, $field[$col], $quo;
\&         }
\&     }
\& else {
\&     print STDERR "parse failed on argument: ",
\&         $csv.error_input, "\en";
\&     $csv.error_diag;
\&     }
.Ve
.SS "Printing \s-1CSV\s0 data"
.IX Subsection "Printing CSV data"
\fIThe fast way: using \*(L"print\*(R"\fR
.IX Subsection "The fast way: using print"
.PP
An example for creating \f(CW\*(C`CSV\*(C'\fR files using the \*(L"print\*(R" method:
.PP
.Vb 6
\& my $csv = Text::CSV.new(eol => $*OUT.nl);
\& open my $fh, ">", "foo.csv" or die "foo.csv: $!";
\& for 1..10 \-> $x {
\&     $csv.print($fh, [ $x, ~$x ]) or $csv.error_diag;
\&     }
\& close $fh or die "$tbl.csv: $!";
.Ve
.PP
\fIThe slow way: using \*(L"combine\*(R" and \*(L"string\*(R"\fR
.IX Subsection "The slow way: using combine and string"
.PP
or using the slower \*(L"combine\*(R" and \*(L"string\*(R" methods:
.PP
.Vb 1
\& my $csv = Text::CSV.new;
\&
\& open my $csv_fh, ">", "hello.csv" or die "hello.csv: $!";
\&
\& my @sample_input_fields = (
\&     \*(AqYou said, "Hello!"\*(Aq,   5.67,
\&     \*(Aq"Surely"\*(Aq,   \*(Aq\*(Aq,   \*(Aq3.14159\*(Aq);
\& if ($csv.combine(@sample_input_fields)) {
\&     print $csv_fh $csv.string, "\en";
\&     }
\& else {
\&     print "combine failed on argument: ",
\&         $csv.error_input, "\en";
\&     }
\& close $csv_fh or die "hello.csv: $!";
.Ve
.SS "Rewriting \s-1CSV\s0"
.IX Subsection "Rewriting CSV"
Rewrite \f(CW\*(C`CSV\*(C'\fR files with \f(CW\*(C`;\*(C'\fR as separator character to well-formed \f(CW\*(C`CSV\*(C'\fR:
.PP
.Vb 2
\& use Text::CSV qw( csv );
\& csv(in => csv(in => "bad.csv", sep => ";"), out => $*OUT);
.Ve
.SS "Dumping database tables to \s-1CSV\s0"
.IX Subsection "Dumping database tables to CSV"
Dumping a database table can be simple as this (\s-1TIMTOWTDI\s0):
.PP
.Vb 2
\& my $dbh = DBI.connect(...);
\& my $sql = "select * from foo";
\&
\& # using your own loop
\& open my $fh, ">", "foo.csv" or die "foo.csv: $!\en";
\& my $csv = Text::CSV.new(eol => "\er\en");
\& my $sth = $dbh.prepare($sql); $sth.execute;
\& $csv.print($fh, $sth.{NAME_lc});
\& while (my $row = $sth.fetch) {
\&     $csv.print($fh, $row);
\&     }
\&
\& # using the csv function, all in memory
\& csv(out => "foo.csv", in => $dbh.selectall_arrayref($sql));
\&
\& # using the csv function, streaming with callbacks
\& my $sth = $dbh.prepare($sql); $sth.execute;
\& csv(out => "foo.csv", in => { $sth.fetch            });
\& csv(out => "foo.csv", in => { $sth.fetchrow_hashref });
.Ve
.PP
Note that this does not discriminate between \*(L"empty\*(R" values and NULL-values
from the database, as both will be the same empty field in \s-1CSV.\s0 To enable
distinction between the two, use \f(CW\*(C`quote_empty\*(C'\fR.
.PP
.Vb 1
\& csv(out => "foo.csv", in => { $sth.fetch }, :quote_empty);
.Ve
.PP
If the database import utility supports special sequences to insert \f(CW\*(C`NULL\*(C'\fR
values into the database, like MySQL/MariaDB supports \f(CW\*(C`\eN\*(C'\fR, use a filter
or a map
.PP
.Vb 2
\& csv(out => "foo.csv", in => { $sth.fetch },
\&                    on_in => { $_ //= "\e\eN" for @$_[1] }); # WIP
\&
\& while (my @row = $sth.fetch) {
\&     $csv.print($fh, @row.map({ * // "\e\eN" }));
\&     }
.Ve
.PP
these special sequences are not recognized by Text::CSV_XS on parsing the
\&\s-1CSV\s0 generated like this, but map and filter are your friends again
.PP
.Vb 3
\& while (my @row = $csv.getline($io)) {
\&     $sth.execute(@row.map({ $_ eq "\e\eN" ?? Nil !! $_ }));
\&     }
\&
\& csv(in => "foo.csv", filter => { 1 => {
\&     $sth.execute(@{$_[1]}.map({ $_ eq "\e\eN" ?? Nil !! $_ }); False; }});
.Ve
.SS "The examples folder"
.IX Subsection "The examples folder"
For more extended examples, see the \fIexamples/\fR \f(CW1\fR) sub-directory in the
original distribution or the git repository \f(CW2\fR).
.PP
.Vb 2
\& 1. https://github.com/Tux/Text\-CSV_XS/tree/master/examples/
\& 2. https://github.com/Tux/Text\-CSV_XS/
.Ve
.PP
The following files can be found there:
.IP "csv-check" 2
.IX Xref "csv-check"
.IX Item "csv-check"
This is a command-line tool to check the \f(CW\*(C`CSV\*(C'\fR file and report on its
content.
.Sp
\&\s-1TODO\s0
.IP "csv2xls" 2
.IX Xref "csv2xls"
.IX Item "csv2xls"
A script to convert \f(CW\*(C`CSV\*(C'\fR to Microsoft Excel.
.Sp
\&\s-1TODO\s0
.IP "csvdiff" 2
.IX Xref "csvdiff"
.IX Item "csvdiff"
A script that provides colorized diff on sorted \s-1CSV\s0 files, assuming first
line is header and first field is the key. Output options include colorized
\&\s-1ANSI\s0 escape codes or \s-1HTML.\s0
.Sp
\&\s-1TODO\s0
.PP
################################################################################
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Microsoft Excel"
.IX Subsection "Microsoft Excel"
The import/export from Microsoft Excel is a \fIrisky task\fR, according to the
documentation in \f(CW\*(C`Text::CSV::Separator\*(C'\fR. Microsoft uses the system's list
separator defined in the regional settings, which happens to be a semicolon
for Dutch, German and Spanish (and probably some others as well). For the
English locale, the default is a comma. In Windows however, the user is
free to choose a predefined locale, and then change \fIevery\fR individual
setting in it, so checking the locale is no solution.
.PP
A lone first line with just
.PP
.Vb 1
\& sep=;
.Ve
.PP
will be recognized and honored: it will set \f(CW\*(C`sep\*(C'\fR to \f(CW\*(C`;\*(C'\fR and skip
that line.
.SH "TODO / WIP / NYI"
.IX Header "TODO / WIP / NYI"
.IP "Real binary data" 2
.IX Item "Real binary data"
The solution would be a working \f(CW\*(C`utf8\-c8\*(C'\fR encoding.
.IP "\s-1BOM\s0 detection" 2
.IX Item "BOM detection"
There is no working solution yet for detection of \s-1BOM\s0 on the \*(L"header\*(R"
method. Besides that, not all encodings are supported in raku.
.IP "on-in and before-print callbacks" 2
.IX Item "on-in and before-print callbacks"
The \*(L"on-in\*(R" callback currently is an alias for \*(L"after-parse\*(R" if the
latter is not specified.
.IP "Examples" 2
.IX Item "Examples"
Convert the perl5 example/tool files to raku versions
.IP "Metadata and \s-1CSV\s0 for the web" 2
.IX Item "Metadata and CSV for the web"
Metadata Vocabulary for Tabular Data <http://w3c.github.io/csvw/metadata/>
(a W3C editor's draft) could be an example for supporting more metadata.
.Sp
W3C's work \s-1CSV\s0 on the Web: Use Cases and
Requirements <http://w3c.github.io/csvw/use-cases-and-requirements/index.html>
is almost finished and worth looking at.
.IP "Cookbook" 2
.IX Item "Cookbook"
Write a document that has recipes for most known non-standard (and maybe
some standard) \f(CW\*(C`CSV\*(C'\fR formats, including formats that use \f(CW\*(C`TAB\*(C'\fR, \f(CW\*(C`;\*(C'\fR,
\&\f(CW\*(C`|\*(C'\fR, or other non-comma separators.
.Sp
Examples could be taken from W3C's \s-1CSV\s0 on the Web: Use Cases and
Requirements <http://w3c.github.io/csvw/use-cases-and-requirements/index.html>
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Still under construction ...
.PP
This section describes the error codes that are used in perl5's module
Text::CSV_XS, and several of these errors are either not applicable in
raku or changed slightly. Once all of the \s-1API\s0 is finished, this section
will be cleaned up. The intention of the error coded however remains.
.PP
If an error occurs, \f(CW\*(C`$csv.error_diag\*(C'\fR can be used to
get information on the cause of the failure. Note that for speed reasons
the internal value is never cleared on success, so using the value returned
by \*(L"error_diag\*(R" in normal cases \- when no error occurred \- may cause
unexpected results.
.PP
If the constructor failed, the cause will be thrown as an Exception that
represents \*(L"error_diag\*(R".
.PP
The \f(CW\*(C`$csv.error_diag\*(C'\fR method is automatically invoked upon error when
the contractor was called with \f(CW\*(C`auto_diag\*(C'\fR set to \f(CW\*(C`True\*(C'\fR.
.PP
Errors can be (individually) caught using the \*(L"error\*(R" callback.
.PP
The errors as described below are available. I have tried to make the error
itself explanatory enough, but more descriptions will be added. For most of
these errors, the first three capitals describe the error category:
.IP "\(bu" 2
\&\s-1INI\s0
.Sp
Initialization error or option conflict.
.IP "\(bu" 2
\&\s-1ECR\s0
.Sp
Carriage-Return related parse error.
.IP "\(bu" 2
\&\s-1EOF\s0
.Sp
End-Of-File related parse error.
.IP "\(bu" 2
\&\s-1EIQ\s0
.Sp
Parse error inside quotation.
.IP "\(bu" 2
\&\s-1EIF\s0
.Sp
Parse error inside field.
.IP "\(bu" 2
\&\s-1ECB\s0
.Sp
Combine error.
.IP "\(bu" 2
\&\s-1EHR\s0
.Sp
Hash parse related error.
.IP "\(bu" 2
\&\s-1EHK\s0
.Sp
Errors related to hooks/callbacks.
.IP "\(bu" 2
\&\s-1CSV\s0
.Sp
Errors related to the csv function.
.PP
And below should be the complete list of error codes that can be returned:
.IP "\(bu" 2
1001 \*(L"\s-1INI\s0 \- separator is equal to quote\- or escape sequence\*(R"
.IX Xref "1001"
.Sp
The separation sequence cannot be equal to the quotation
sequence or to the escape sequence, as this
would invalidate all parsing rules.
.IP "\(bu" 2
1002 \*(L"\s-1INI\s0 \- allow_whitespace with escape_char or quote_char \s-1SP\s0 or \s-1TAB\*(R"\s0
.IX Xref "1002"
.Sp
Using the \f(CW\*(C`allow_whitespace\*(C'\fR attribute when either
\&\f(CW\*(C`quote_char\*(C'\fR or \f(CW\*(C`escape_char\*(C'\fR is equal to
\&\f(CW\*(C`SPACE\*(C'\fR or \f(CW\*(C`TAB\*(C'\fR is too ambiguous to allow.
.IP "\(bu" 2
1003 \*(L"\s-1INI\s0 \- \er or \en in main attr not allowed\*(R"
.IX Xref "1003"
.Sp
Using default \f(CW\*(C`eol\*(C'\fR sequences in either
separation sequence, quotation sequence, or
escape sequence is not allowed.
.IP "\(bu" 2
1004 \*(L"\s-1INI\s0 \- callbacks should be undefined or a hashref\*(R"
.IX Xref "1004"
.Sp
The \f(CW\*(C`callbacks\*(C'\fR attribute only allows one to be undefined or
a hash reference.
.IP "\(bu" 2
1010 \*(L"\s-1INI\s0 \- the header is empty\*(R"
.IX Xref "1010"
.Sp
The header line parsed in the \*(L"header\*(R" is empty.
.IP "\(bu" 2
1011 \*(L"\s-1INI\s0 \- the header contains more than one valid separator\*(R"
.IX Xref "1011"
.Sp
The header line parsed in the \*(L"header\*(R" contains more than one (unique)
separator character out of the allowed set of separators.
.IP "\(bu" 2
1012 \*(L"\s-1INI\s0 \- the header contains an empty field\*(R"
.IX Xref "1012"
.Sp
The header line parsed in the \*(L"header\*(R" is contains an empty field.
.IP "\(bu" 2
1013 \*(L"\s-1INI\s0 \- the header contains nun-unique fields\*(R"
.IX Xref "1013"
.Sp
The header line parsed in the \*(L"header\*(R" contains at least two identical
fields.
.IP "\(bu" 2
2010 \*(L"\s-1ECR\s0 \- \s-1QUO\s0 char inside quotes followed by \s-1CR\s0 not part of \s-1EOL\*(R"\s0
.IX Xref "2010"
.Sp
When \f(CW\*(C`eol\*(C'\fR has been set to anything but the default, like
\&\f(CW"\er\et\en"\fR, and the \f(CW"\er"\fR is following the \fBsecond\fR (closing)
\&\f(CW\*(C`quote_char\*(C'\fR, where the characters following the \f(CW"\er"\fR do
not make up the \f(CW\*(C`eol\*(C'\fR sequence, this is an error.
.IP "\(bu" 2
2011 \*(L"\s-1ECR\s0 \- Characters after end of quoted field\*(R"
.IX Xref "2011"
.Sp
Sequences like \f(CW\*(C`1,foo,"bar"baz,22,1\*(C'\fR are not allowed. \f(CW"bar"\fR is a quoted
field and after the closing double-quote, there should be either a new-line
sequence or a separation sequence.
.IP "\(bu" 2
2012 \*(L"\s-1EOF\s0 \- End of data in parsing input stream\*(R"
.IX Xref "2012"
.Sp
Self-explaining. End-of-file while inside parsing a stream. Can happen only
when reading from streams with \*(L"getline\*(R", as using \*(L"parse\*(R" is done on
strings that are not required to have a trailing \f(CW\*(C`eol\*(C'\fR.
.IP "\(bu" 2
2013 \*(L"\s-1INI\s0 \- Specification error for fragments \s-1RFC7111\*(R"\s0
.IX Xref "2013"
.Sp
Invalid specification for \s-1URI\s0 \*(L"fragment\*(R" specification.
.IP "\(bu" 2
2021 \*(L"\s-1EIQ\s0 \- \s-1NL\s0 char inside quotes, binary off\*(R"
.IX Xref "2021"
.Sp
Sequences like \f(CW\*(C`1,"foo\enbar",22,1\*(C'\fR are allowed only when the binary option
has been selected with the constructor.
.IP "\(bu" 2
2022 \*(L"\s-1EIQ\s0 \- \s-1CR\s0 char inside quotes, binary off\*(R"
.IX Xref "2022"
.Sp
Sequences like \f(CW\*(C`1,"foo\erbar",22,1\*(C'\fR are allowed only when the binary option
has been selected with the constructor.
.IP "\(bu" 2
2023 \*(L"\s-1EIQ\s0 \- \s-1QUO\s0 sequence not allowed\*(R"
.IX Xref "2023"
.Sp
Sequences like \f(CW\*(C`"foo "bar" baz",qu\*(C'\fR and \f(CW\*(C`2023,",2008\-04\-05,"Foo, Bar",\en\*(C'\fR
will cause this error.
.IP "\(bu" 2
2024 \*(L"\s-1EIQ\s0 \- \s-1EOF\s0 cannot be escaped, not even inside quotes\*(R"
.IX Xref "2024"
.Sp
The escape sequence is not allowed as last item in an input stream.
.IP "\(bu" 2
2025 \*(L"\s-1EIQ\s0 \- Loose unescaped escape\*(R"
.IX Xref "2025"
.Sp
An escape sequence should escape only characters that need escaping.
.Sp
Allowing the escape for other characters is possible with the attribute
\&\*(L"allow_loose_escapes\*(R".
.IP "\(bu" 2
2026 \*(L"\s-1EIQ\s0 \- Binary character inside quoted field, binary off\*(R"
.IX Xref "2026"
.Sp
Binary characters are not allowed by default. Exceptions are fields that
contain valid \s-1UTF\-8,\s0 that will automatically be upgraded if the content is
valid \s-1UTF\-8.\s0 Set \f(CW\*(C`binary\*(C'\fR to \f(CW1\fR to accept binary data.
.IP "\(bu" 2
2027 \*(L"\s-1EIQ\s0 \- Quoted field not terminated\*(R"
.IX Xref "2027"
.Sp
When parsing a field that started with a quotation sequence, the field is
expected to be closed with a quotation sequence. When the parsed line is
exhausted before the quote is found, that field is not terminated.
.IP "\(bu" 2
2030 \*(L"\s-1EIF\s0 \- \s-1NL\s0 char inside unquoted verbatim, binary off\*(R"
.IX Xref "2030"
.IP "\(bu" 2
2031 \*(L"\s-1EIF\s0 \- \s-1CR\s0 char is first char of field, not part of \s-1EOL\*(R"\s0
.IX Xref "2031"
.IP "\(bu" 2
2032 \*(L"\s-1EIF\s0 \- \s-1CR\s0 char inside unquoted, not part of \s-1EOL\*(R"\s0
.IX Xref "2032"
.IP "\(bu" 2
2034 \*(L"\s-1EIF\s0 \- Loose unescaped quote\*(R"
.IX Xref "2034"
.IP "\(bu" 2
2035 \*(L"\s-1EIF\s0 \- Escaped \s-1EOF\s0 in unquoted field\*(R"
.IX Xref "2035"
.IP "\(bu" 2
2036 \*(L"\s-1EIF\s0 \- \s-1ESC\s0 error\*(R"
.IX Xref "2036"
.IP "\(bu" 2
2037 \*(L"\s-1EIF\s0 \- Binary character in unquoted field, binary off\*(R"
.IX Xref "2037"
.IP "\(bu" 2
2110 \*(L"\s-1ECB\s0 \- Binary character in Combine, binary off\*(R"
.IX Xref "2110"
.IP "\(bu" 2
2200 \*(L"\s-1EIO\s0 \- print to \s-1IO\s0 failed. See errno\*(R"
.IX Xref "2200"
.IP "\(bu" 2
3001 \*(L"\s-1EHR\s0 \- Unsupported syntax for column_names\*(R"
.IX Xref "3001"
.IP "\(bu" 2
3002 \*(L"\s-1EHR\s0 \- getline_hr called before column_names\*(R"
.IX Xref "3002"
.IP "\(bu" 2
3003 \*(L"\s-1EHR\s0 \- bind_columns and column_names fields count mismatch\*(R"
.IX Xref "3003"
.IP "\(bu" 2
3004 \*(L"\s-1EHR\s0 \- bind_columns only accepts refs to scalars\*(R"
.IX Xref "3004"
.IP "\(bu" 2
3006 \*(L"\s-1EHR\s0 \- bind_columns did not pass enough refs for parsed fields\*(R"
.IX Xref "3006"
.IP "\(bu" 2
3007 \*(L"\s-1EHR\s0 \- bind_columns needs refs to writable scalars\*(R"
.IX Xref "3007"
.IP "\(bu" 2
3008 \*(L"\s-1EHR\s0 \- unexpected error in bound fields\*(R"
.IX Xref "3008"
.IP "\(bu" 2
3009 \*(L"\s-1EHR\s0 \- print_hr called before column_names\*(R"
.IX Xref "3009"
.IP "\(bu" 2
3010 \*(L"\s-1EHR\s0 \- print_hr called with invalid arguments\*(R"
.IX Xref "3010"
.IP "\(bu" 2
3100 \*(L"\s-1EHK\s0 \- Unsupported callback\*(R"
.IX Xref "3100"
.IP "\(bu" 2
4001 \*(L"\s-1PRM\s0 \- The key does not exist as field in the data\*(R",
.IX Xref "4001"
.Sp
You cannot set the key from a non-existing column.
.Sp
If you were using a key list, \fIall\fR keys should exist.
.IP "\(bu" 2
5000 \*(L"\s-1CSV\s0 \- Unsupported type for in\*(R"
.IX Xref "5000"
.IP "\(bu" 2
5001 \*(L"\s-1CSV\s0 \- Unsupported type for out\*(R"
.IX Xref "5001"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Modules in perl5:
.PP
IO::File, IO::Handle, IO::Wrap, Text::CSV_XS, Text::CSV,
Text::CSV_PP, Text::CSV::Encoded, Text::CSV::Separator,
Text::CSV::Slurp, Spreadsheet::CSV and Spreadsheet::Read;
.SH "AUTHOR"
.IX Header "AUTHOR"
H.Merijn Brand \fI<h.m.brand@xs4all.nl>\fR wrote this based on the
features provided by perl5's Text::CSV_XS.
.PP
Liz Mattijsen helped in getting the best out of raku.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 1
\& Copyright (C) 2014\-2018 H.Merijn Brand. All rights reserved.
.Ve
.PP
This library is free software; you can redistribute and/or modify it under
the same terms as Perl itself.
